{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/zurb:foundation-sites/_build/assets/js/plugins/foundation.slider.js","filenameRelative":"/packages/zurb:foundation-sites/_build/assets/js/plugins/foundation.slider.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/zurb:foundation-sites/_build/assets/js/plugins/foundation.slider.js.map","sourceFileName":"/packages/zurb:foundation-sites/_build/assets/js/plugins/foundation.slider.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"foundation.slider"},"ignored":false,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n!function ($) {\n\n  /**\n   * Slider module.\n   * @module foundation.slider\n   * @requires foundation.util.motion\n   * @requires foundation.util.triggers\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.touch\n   */\n\n  var Slider = function () {\n    /**\n     * Creates a new instance of a drilldown menu.\n     * @class\n     * @param {jQuery} element - jQuery object to make into an accordion menu.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n\n    function Slider(element, options) {\n      _classCallCheck(this, Slider);\n\n      this.$element = element;\n      this.options = $.extend({}, Slider.defaults, this.$element.data(), options);\n\n      this._init();\n\n      Foundation.registerPlugin(this, 'Slider');\n      Foundation.Keyboard.register('Slider', {\n        'ltr': {\n          'ARROW_RIGHT': 'increase',\n          'ARROW_UP': 'increase',\n          'ARROW_DOWN': 'decrease',\n          'ARROW_LEFT': 'decrease',\n          'SHIFT_ARROW_RIGHT': 'increase_fast',\n          'SHIFT_ARROW_UP': 'increase_fast',\n          'SHIFT_ARROW_DOWN': 'decrease_fast',\n          'SHIFT_ARROW_LEFT': 'decrease_fast'\n        },\n        'rtl': {\n          'ARROW_LEFT': 'increase',\n          'ARROW_RIGHT': 'decrease',\n          'SHIFT_ARROW_LEFT': 'increase_fast',\n          'SHIFT_ARROW_RIGHT': 'decrease_fast'\n        }\n      });\n    }\n\n    /**\n     * Initilizes the plugin by reading/setting attributes, creating collections and setting the initial position of the handle(s).\n     * @function\n     * @private\n     */\n\n    _createClass(Slider, [{\n      key: '_init',\n      value: function () {\n        function _init() {\n          this.inputs = this.$element.find('input');\n          this.handles = this.$element.find('[data-slider-handle]');\n\n          this.$handle = this.handles.eq(0);\n          this.$input = this.inputs.length ? this.inputs.eq(0) : $('#' + this.$handle.attr('aria-controls'));\n          this.$fill = this.$element.find('[data-slider-fill]').css(this.options.vertical ? 'height' : 'width', 0);\n\n          var isDbl = false,\n              _this = this;\n          if (this.options.disabled || this.$element.hasClass(this.options.disabledClass)) {\n            this.options.disabled = true;\n            this.$element.addClass(this.options.disabledClass);\n          }\n          if (!this.inputs.length) {\n            this.inputs = $().add(this.$input);\n            this.options.binding = true;\n          }\n          this._setInitAttr(0);\n          this._events(this.$handle);\n\n          if (this.handles[1]) {\n            this.options.doubleSided = true;\n            this.$handle2 = this.handles.eq(1);\n            this.$input2 = this.inputs.length > 1 ? this.inputs.eq(1) : $('#' + this.$handle2.attr('aria-controls'));\n\n            if (!this.inputs[1]) {\n              this.inputs = this.inputs.add(this.$input2);\n            }\n            isDbl = true;\n\n            this._setHandlePos(this.$handle, this.options.initialStart, true, function () {\n\n              _this._setHandlePos(_this.$handle2, _this.options.initialEnd, true);\n            });\n            // this.$handle.triggerHandler('click.zf.slider');\n            this._setInitAttr(1);\n            this._events(this.$handle2);\n          }\n\n          if (!isDbl) {\n            this._setHandlePos(this.$handle, this.options.initialStart, true);\n          }\n        }\n\n        return _init;\n      }()\n\n      /**\n       * Sets the position of the selected handle and fill bar.\n       * @function\n       * @private\n       * @param {jQuery} $hndl - the selected handle to move.\n       * @param {Number} location - floating point between the start and end values of the slider bar.\n       * @param {Function} cb - callback function to fire on completion.\n       * @fires Slider#moved\n       * @fires Slider#changed\n       */\n\n    }, {\n      key: '_setHandlePos',\n      value: function () {\n        function _setHandlePos($hndl, location, noInvert, cb) {\n          // don't move if the slider has been disabled since its initialization\n          if (this.$element.hasClass(this.options.disabledClass)) {\n            return;\n          }\n          //might need to alter that slightly for bars that will have odd number selections.\n          location = parseFloat(location); //on input change events, convert string to number...grumble.\n\n          // prevent slider from running out of bounds, if value exceeds the limits set through options, override the value to min/max\n          if (location < this.options.start) {\n            location = this.options.start;\n          } else if (location > this.options.end) {\n            location = this.options.end;\n          }\n\n          var isDbl = this.options.doubleSided;\n\n          if (isDbl) {\n            //this block is to prevent 2 handles from crossing eachother. Could/should be improved.\n            if (this.handles.index($hndl) === 0) {\n              var h2Val = parseFloat(this.$handle2.attr('aria-valuenow'));\n              location = location >= h2Val ? h2Val - this.options.step : location;\n            } else {\n              var h1Val = parseFloat(this.$handle.attr('aria-valuenow'));\n              location = location <= h1Val ? h1Val + this.options.step : location;\n            }\n          }\n\n          //this is for single-handled vertical sliders, it adjusts the value to account for the slider being \"upside-down\"\n          //for click and drag events, it's weird due to the scale(-1, 1) css property\n          if (this.options.vertical && !noInvert) {\n            location = this.options.end - location;\n          }\n\n          var _this = this,\n              vert = this.options.vertical,\n              hOrW = vert ? 'height' : 'width',\n              lOrT = vert ? 'top' : 'left',\n              handleDim = $hndl[0].getBoundingClientRect()[hOrW],\n              elemDim = this.$element[0].getBoundingClientRect()[hOrW],\n\n\n          //percentage of bar min/max value based on click or drag point\n          pctOfBar = percent(location - this.options.start, this.options.end - this.options.start).toFixed(2),\n\n\n          //number of actual pixels to shift the handle, based on the percentage obtained above\n          pxToMove = (elemDim - handleDim) * pctOfBar,\n\n\n          //percentage of bar to shift the handle\n          movement = (percent(pxToMove, elemDim) * 100).toFixed(this.options.decimal);\n          //fixing the decimal value for the location number, is passed to other methods as a fixed floating-point value\n          location = parseFloat(location.toFixed(this.options.decimal));\n          // declare empty object for css adjustments, only used with 2 handled-sliders\n          var css = {};\n\n          this._setValues($hndl, location);\n\n          // TODO update to calculate based on values set to respective inputs??\n          if (isDbl) {\n            var isLeftHndl = this.handles.index($hndl) === 0,\n\n\n            //empty variable, will be used for min-height/width for fill bar\n            dim,\n\n\n            //percentage w/h of the handle compared to the slider bar\n            handlePct = ~~(percent(handleDim, elemDim) * 100);\n            //if left handle, the math is slightly different than if it's the right handle, and the left/top property needs to be changed for the fill bar\n            if (isLeftHndl) {\n              //left or top percentage value to apply to the fill bar.\n              css[lOrT] = movement + '%';\n              //calculate the new min-height/width for the fill bar.\n              dim = parseFloat(this.$handle2[0].style[lOrT]) - movement + handlePct;\n              //this callback is necessary to prevent errors and allow the proper placement and initialization of a 2-handled slider\n              //plus, it means we don't care if 'dim' isNaN on init, it won't be in the future.\n              if (cb && typeof cb === 'function') {\n                cb();\n              } //this is only needed for the initialization of 2 handled sliders\n            } else {\n                //just caching the value of the left/bottom handle's left/top property\n                var handlePos = parseFloat(this.$handle[0].style[lOrT]);\n                //calculate the new min-height/width for the fill bar. Use isNaN to prevent false positives for numbers <= 0\n                //based on the percentage of movement of the handle being manipulated, less the opposing handle's left/top position, plus the percentage w/h of the handle itself\n                dim = movement - (isNaN(handlePos) ? this.options.initialStart / ((this.options.end - this.options.start) / 100) : handlePos) + handlePct;\n              }\n            // assign the min-height/width to our css object\n            css['min-' + hOrW] = dim + '%';\n          }\n\n          this.$element.one('finished.zf.animate', function () {\n            /**\n             * Fires when the handle is done moving.\n             * @event Slider#moved\n             */\n            _this.$element.trigger('moved.zf.slider', [$hndl]);\n          });\n\n          //because we don't know exactly how the handle will be moved, check the amount of time it should take to move.\n          var moveTime = this.$element.data('dragging') ? 1000 / 60 : this.options.moveTime;\n\n          Foundation.Move(moveTime, $hndl, function () {\n            //adjusting the left/top property of the handle, based on the percentage calculated above\n            $hndl.css(lOrT, movement + '%');\n\n            if (!_this.options.doubleSided) {\n              //if single-handled, a simple method to expand the fill bar\n              _this.$fill.css(hOrW, pctOfBar * 100 + '%');\n            } else {\n              //otherwise, use the css object we created above\n              _this.$fill.css(css);\n            }\n          });\n\n          /**\n           * Fires when the value has not been change for a given time.\n           * @event Slider#changed\n           */\n          clearTimeout(_this.timeout);\n          _this.timeout = setTimeout(function () {\n            _this.$element.trigger('changed.zf.slider', [$hndl]);\n          }, _this.options.changedDelay);\n        }\n\n        return _setHandlePos;\n      }()\n\n      /**\n       * Sets the initial attribute for the slider element.\n       * @function\n       * @private\n       * @param {Number} idx - index of the current handle/input to use.\n       */\n\n    }, {\n      key: '_setInitAttr',\n      value: function () {\n        function _setInitAttr(idx) {\n          var id = this.inputs.eq(idx).attr('id') || Foundation.GetYoDigits(6, 'slider');\n          this.inputs.eq(idx).attr({\n            'id': id,\n            'max': this.options.end,\n            'min': this.options.start,\n            'step': this.options.step\n          });\n          this.handles.eq(idx).attr({\n            'role': 'slider',\n            'aria-controls': id,\n            'aria-valuemax': this.options.end,\n            'aria-valuemin': this.options.start,\n            'aria-valuenow': idx === 0 ? this.options.initialStart : this.options.initialEnd,\n            'aria-orientation': this.options.vertical ? 'vertical' : 'horizontal',\n            'tabindex': 0\n          });\n        }\n\n        return _setInitAttr;\n      }()\n\n      /**\n       * Sets the input and `aria-valuenow` values for the slider element.\n       * @function\n       * @private\n       * @param {jQuery} $handle - the currently selected handle.\n       * @param {Number} val - floating point of the new value.\n       */\n\n    }, {\n      key: '_setValues',\n      value: function () {\n        function _setValues($handle, val) {\n          var idx = this.options.doubleSided ? this.handles.index($handle) : 0;\n          this.inputs.eq(idx).val(val);\n          $handle.attr('aria-valuenow', val);\n        }\n\n        return _setValues;\n      }()\n\n      /**\n       * Handles events on the slider element.\n       * Calculates the new location of the current handle.\n       * If there are two handles and the bar was clicked, it determines which handle to move.\n       * @function\n       * @private\n       * @param {Object} e - the `event` object passed from the listener.\n       * @param {jQuery} $handle - the current handle to calculate for, if selected.\n       * @param {Number} val - floating point number for the new value of the slider.\n       * TODO clean this up, there's a lot of repeated code between this and the _setHandlePos fn.\n       */\n\n    }, {\n      key: '_handleEvent',\n      value: function () {\n        function _handleEvent(e, $handle, val) {\n          var value, hasVal;\n          if (!val) {\n            //click or drag events\n            e.preventDefault();\n            var _this = this,\n                vertical = this.options.vertical,\n                param = vertical ? 'height' : 'width',\n                direction = vertical ? 'top' : 'left',\n                eventOffset = vertical ? e.pageY : e.pageX,\n                halfOfHandle = this.$handle[0].getBoundingClientRect()[param] / 2,\n                barDim = this.$element[0].getBoundingClientRect()[param],\n                windowScroll = vertical ? $(window).scrollTop() : $(window).scrollLeft();\n\n            var elemOffset = this.$element.offset()[direction];\n\n            // touch events emulated by the touch util give position relative to screen, add window.scroll to event coordinates...\n            // best way to guess this is simulated is if clientY == pageY\n            if (e.clientY === e.pageY) {\n              eventOffset = eventOffset + windowScroll;\n            }\n            var eventFromBar = eventOffset - elemOffset;\n            var barXY;\n            if (eventFromBar < 0) {\n              barXY = 0;\n            } else if (eventFromBar > barDim) {\n              barXY = barDim;\n            } else {\n              barXY = eventFromBar;\n            }\n            offsetPct = percent(barXY, barDim);\n\n            value = (this.options.end - this.options.start) * offsetPct + this.options.start;\n\n            // turn everything around for RTL, yay math!\n            if (Foundation.rtl() && !this.options.vertical) {\n              value = this.options.end - value;\n            }\n\n            value = _this._adjustValue(null, value);\n            //boolean flag for the setHandlePos fn, specifically for vertical sliders\n            hasVal = false;\n\n            if (!$handle) {\n              //figure out which handle it is, pass it to the next function.\n              var firstHndlPos = absPosition(this.$handle, direction, barXY, param),\n                  secndHndlPos = absPosition(this.$handle2, direction, barXY, param);\n              $handle = firstHndlPos <= secndHndlPos ? this.$handle : this.$handle2;\n            }\n          } else {\n            //change event on input\n            value = this._adjustValue(null, val);\n            hasVal = true;\n          }\n\n          this._setHandlePos($handle, value, hasVal);\n        }\n\n        return _handleEvent;\n      }()\n\n      /**\n       * Adjustes value for handle in regard to step value. returns adjusted value\n       * @function\n       * @private\n       * @param {jQuery} $handle - the selected handle.\n       * @param {Number} value - value to adjust. used if $handle is falsy\n       */\n\n    }, {\n      key: '_adjustValue',\n      value: function () {\n        function _adjustValue($handle, value) {\n          var val,\n              step = this.options.step,\n              div = parseFloat(step / 2),\n              left,\n              prev_val,\n              next_val;\n          if (!!$handle) {\n            val = parseFloat($handle.attr('aria-valuenow'));\n          } else {\n            val = value;\n          }\n          left = val % step;\n          prev_val = val - left;\n          next_val = prev_val + step;\n          if (left === 0) {\n            return val;\n          }\n          val = val >= prev_val + div ? next_val : prev_val;\n          return val;\n        }\n\n        return _adjustValue;\n      }()\n\n      /**\n       * Adds event listeners to the slider elements.\n       * @function\n       * @private\n       * @param {jQuery} $handle - the current handle to apply listeners to.\n       */\n\n    }, {\n      key: '_events',\n      value: function () {\n        function _events($handle) {\n          var _this = this,\n              curHandle,\n              timer;\n\n          this.inputs.off('change.zf.slider').on('change.zf.slider', function (e) {\n            var idx = _this.inputs.index($(this));\n            _this._handleEvent(e, _this.handles.eq(idx), $(this).val());\n          });\n\n          if (this.options.clickSelect) {\n            this.$element.off('click.zf.slider').on('click.zf.slider', function (e) {\n              if (_this.$element.data('dragging')) {\n                return false;\n              }\n\n              if (!$(e.target).is('[data-slider-handle]')) {\n                if (_this.options.doubleSided) {\n                  _this._handleEvent(e);\n                } else {\n                  _this._handleEvent(e, _this.$handle);\n                }\n              }\n            });\n          }\n\n          if (this.options.draggable) {\n            this.handles.addTouch();\n\n            var $body = $('body');\n            $handle.off('mousedown.zf.slider').on('mousedown.zf.slider', function (e) {\n              $handle.addClass('is-dragging');\n              _this.$fill.addClass('is-dragging'); //\n              _this.$element.data('dragging', true);\n\n              curHandle = $(e.currentTarget);\n\n              $body.on('mousemove.zf.slider', function (e) {\n                e.preventDefault();\n                _this._handleEvent(e, curHandle);\n              }).on('mouseup.zf.slider', function (e) {\n                _this._handleEvent(e, curHandle);\n\n                $handle.removeClass('is-dragging');\n                _this.$fill.removeClass('is-dragging');\n                _this.$element.data('dragging', false);\n\n                $body.off('mousemove.zf.slider mouseup.zf.slider');\n              });\n            })\n            // prevent events triggered by touch\n            .on('selectstart.zf.slider touchmove.zf.slider', function (e) {\n              e.preventDefault();\n            });\n          }\n\n          $handle.off('keydown.zf.slider').on('keydown.zf.slider', function (e) {\n            var _$handle = $(this),\n                idx = _this.options.doubleSided ? _this.handles.index(_$handle) : 0,\n                oldValue = parseFloat(_this.inputs.eq(idx).val()),\n                newValue;\n\n            // handle keyboard event with keyboard util\n            Foundation.Keyboard.handleKey(e, 'Slider', {\n              decrease: function () {\n                function decrease() {\n                  newValue = oldValue - _this.options.step;\n                }\n\n                return decrease;\n              }(),\n              increase: function () {\n                function increase() {\n                  newValue = oldValue + _this.options.step;\n                }\n\n                return increase;\n              }(),\n              decrease_fast: function () {\n                function decrease_fast() {\n                  newValue = oldValue - _this.options.step * 10;\n                }\n\n                return decrease_fast;\n              }(),\n              increase_fast: function () {\n                function increase_fast() {\n                  newValue = oldValue + _this.options.step * 10;\n                }\n\n                return increase_fast;\n              }(),\n              handled: function () {\n                function handled() {\n                  // only set handle pos when event was handled specially\n                  e.preventDefault();\n                  _this._setHandlePos(_$handle, newValue, true);\n                }\n\n                return handled;\n              }()\n            });\n            /*if (newValue) { // if pressed key has special function, update value\n              e.preventDefault();\n              _this._setHandlePos(_$handle, newValue);\n            }*/\n          });\n        }\n\n        return _events;\n      }()\n\n      /**\n       * Destroys the slider plugin.\n       */\n\n    }, {\n      key: 'destroy',\n      value: function () {\n        function destroy() {\n          this.handles.off('.zf.slider');\n          this.inputs.off('.zf.slider');\n          this.$element.off('.zf.slider');\n\n          Foundation.unregisterPlugin(this);\n        }\n\n        return destroy;\n      }()\n    }]);\n\n    return Slider;\n  }();\n\n  Slider.defaults = {\n    /**\n     * Minimum value for the slider scale.\n     * @option\n     * @example 0\n     */\n    start: 0,\n    /**\n     * Maximum value for the slider scale.\n     * @option\n     * @example 100\n     */\n    end: 100,\n    /**\n     * Minimum value change per change event.\n     * @option\n     * @example 1\n     */\n    step: 1,\n    /**\n     * Value at which the handle/input *(left handle/first input)* should be set to on initialization.\n     * @option\n     * @example 0\n     */\n    initialStart: 0,\n    /**\n     * Value at which the right handle/second input should be set to on initialization.\n     * @option\n     * @example 100\n     */\n    initialEnd: 100,\n    /**\n     * Allows the input to be located outside the container and visible. Set to by the JS\n     * @option\n     * @example false\n     */\n    binding: false,\n    /**\n     * Allows the user to click/tap on the slider bar to select a value.\n     * @option\n     * @example true\n     */\n    clickSelect: true,\n    /**\n     * Set to true and use the `vertical` class to change alignment to vertical.\n     * @option\n     * @example false\n     */\n    vertical: false,\n    /**\n     * Allows the user to drag the slider handle(s) to select a value.\n     * @option\n     * @example true\n     */\n    draggable: true,\n    /**\n     * Disables the slider and prevents event listeners from being applied. Double checked by JS with `disabledClass`.\n     * @option\n     * @example false\n     */\n    disabled: false,\n    /**\n     * Allows the use of two handles. Double checked by the JS. Changes some logic handling.\n     * @option\n     * @example false\n     */\n    doubleSided: false,\n    /**\n     * Potential future feature.\n     */\n    // steps: 100,\n    /**\n     * Number of decimal places the plugin should go to for floating point precision.\n     * @option\n     * @example 2\n     */\n    decimal: 2,\n    /**\n     * Time delay for dragged elements.\n     */\n    // dragDelay: 0,\n    /**\n     * Time, in ms, to animate the movement of a slider handle if user clicks/taps on the bar. Needs to be manually set if updating the transition time in the Sass settings.\n     * @option\n     * @example 200\n     */\n    moveTime: 200, //update this if changing the transition time in the sass\n    /**\n     * Class applied to disabled sliders.\n     * @option\n     * @example 'disabled'\n     */\n    disabledClass: 'disabled',\n    /**\n     * Will invert the default layout for a vertical<span data-tooltip title=\"who would do this???\"> </span>slider.\n     * @option\n     * @example false\n     */\n    invertVertical: false,\n    /**\n     * Milliseconds before the `changed.zf-slider` event is triggered after value change.\n     * @option\n     * @example 500\n     */\n    changedDelay: 500\n  };\n\n  function percent(frac, num) {\n    return frac / num;\n  }\n  function absPosition($handle, dir, clickPos, param) {\n    return Math.abs($handle.position()[dir] + $handle[param]() / 2 - clickPos);\n  }\n\n  // Window exports\n  Foundation.plugin(Slider, 'Slider');\n}(jQuery);\n\n//*********this is in case we go to static, absolute positions instead of dynamic positioning********\n// this.setSteps(function() {\n//   _this._events();\n//   var initStart = _this.options.positions[_this.options.initialStart - 1] || null;\n//   var initEnd = _this.options.initialEnd ? _this.options.position[_this.options.initialEnd - 1] : null;\n//   if (initStart || initEnd) {\n//     _this._handleEvent(initStart, initEnd);\n//   }\n// });\n\n//***********the other part of absolute positions*************\n// Slider.prototype.setSteps = function(cb) {\n//   var posChange = this.$element.outerWidth() / this.options.steps;\n//   var counter = 0\n//   while(counter < this.options.steps) {\n//     if (counter) {\n//       this.options.positions.push(this.options.positions[counter - 1] + posChange);\n//     } else {\n//       this.options.positions.push(posChange);\n//     }\n//     counter++;\n//   }\n//   cb();\n// };","ast":null,"map":{"version":3,"sources":["/packages/zurb:foundation-sites/_build/assets/js/plugins/foundation.slider.js"],"names":[],"mappings":"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","file":"/packages/zurb:foundation-sites/_build/assets/js/plugins/foundation.slider.js.map","sourcesContent":["'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * Slider module.\n   * @module foundation.slider\n   * @requires foundation.util.motion\n   * @requires foundation.util.triggers\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.touch\n   */\n\n  var Slider = function () {\n    /**\n     * Creates a new instance of a drilldown menu.\n     * @class\n     * @param {jQuery} element - jQuery object to make into an accordion menu.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n\n    function Slider(element, options) {\n      _classCallCheck(this, Slider);\n\n      this.$element = element;\n      this.options = $.extend({}, Slider.defaults, this.$element.data(), options);\n\n      this._init();\n\n      Foundation.registerPlugin(this, 'Slider');\n      Foundation.Keyboard.register('Slider', {\n        'ltr': {\n          'ARROW_RIGHT': 'increase',\n          'ARROW_UP': 'increase',\n          'ARROW_DOWN': 'decrease',\n          'ARROW_LEFT': 'decrease',\n          'SHIFT_ARROW_RIGHT': 'increase_fast',\n          'SHIFT_ARROW_UP': 'increase_fast',\n          'SHIFT_ARROW_DOWN': 'decrease_fast',\n          'SHIFT_ARROW_LEFT': 'decrease_fast'\n        },\n        'rtl': {\n          'ARROW_LEFT': 'increase',\n          'ARROW_RIGHT': 'decrease',\n          'SHIFT_ARROW_LEFT': 'increase_fast',\n          'SHIFT_ARROW_RIGHT': 'decrease_fast'\n        }\n      });\n    }\n\n    /**\n     * Initilizes the plugin by reading/setting attributes, creating collections and setting the initial position of the handle(s).\n     * @function\n     * @private\n     */\n\n\n    _createClass(Slider, [{\n      key: '_init',\n      value: function _init() {\n        this.inputs = this.$element.find('input');\n        this.handles = this.$element.find('[data-slider-handle]');\n\n        this.$handle = this.handles.eq(0);\n        this.$input = this.inputs.length ? this.inputs.eq(0) : $('#' + this.$handle.attr('aria-controls'));\n        this.$fill = this.$element.find('[data-slider-fill]').css(this.options.vertical ? 'height' : 'width', 0);\n\n        var isDbl = false,\n            _this = this;\n        if (this.options.disabled || this.$element.hasClass(this.options.disabledClass)) {\n          this.options.disabled = true;\n          this.$element.addClass(this.options.disabledClass);\n        }\n        if (!this.inputs.length) {\n          this.inputs = $().add(this.$input);\n          this.options.binding = true;\n        }\n        this._setInitAttr(0);\n        this._events(this.$handle);\n\n        if (this.handles[1]) {\n          this.options.doubleSided = true;\n          this.$handle2 = this.handles.eq(1);\n          this.$input2 = this.inputs.length > 1 ? this.inputs.eq(1) : $('#' + this.$handle2.attr('aria-controls'));\n\n          if (!this.inputs[1]) {\n            this.inputs = this.inputs.add(this.$input2);\n          }\n          isDbl = true;\n\n          this._setHandlePos(this.$handle, this.options.initialStart, true, function () {\n\n            _this._setHandlePos(_this.$handle2, _this.options.initialEnd, true);\n          });\n          // this.$handle.triggerHandler('click.zf.slider');\n          this._setInitAttr(1);\n          this._events(this.$handle2);\n        }\n\n        if (!isDbl) {\n          this._setHandlePos(this.$handle, this.options.initialStart, true);\n        }\n      }\n\n      /**\n       * Sets the position of the selected handle and fill bar.\n       * @function\n       * @private\n       * @param {jQuery} $hndl - the selected handle to move.\n       * @param {Number} location - floating point between the start and end values of the slider bar.\n       * @param {Function} cb - callback function to fire on completion.\n       * @fires Slider#moved\n       * @fires Slider#changed\n       */\n\n    }, {\n      key: '_setHandlePos',\n      value: function _setHandlePos($hndl, location, noInvert, cb) {\n        // don't move if the slider has been disabled since its initialization\n        if (this.$element.hasClass(this.options.disabledClass)) {\n          return;\n        }\n        //might need to alter that slightly for bars that will have odd number selections.\n        location = parseFloat(location); //on input change events, convert string to number...grumble.\n\n        // prevent slider from running out of bounds, if value exceeds the limits set through options, override the value to min/max\n        if (location < this.options.start) {\n          location = this.options.start;\n        } else if (location > this.options.end) {\n          location = this.options.end;\n        }\n\n        var isDbl = this.options.doubleSided;\n\n        if (isDbl) {\n          //this block is to prevent 2 handles from crossing eachother. Could/should be improved.\n          if (this.handles.index($hndl) === 0) {\n            var h2Val = parseFloat(this.$handle2.attr('aria-valuenow'));\n            location = location >= h2Val ? h2Val - this.options.step : location;\n          } else {\n            var h1Val = parseFloat(this.$handle.attr('aria-valuenow'));\n            location = location <= h1Val ? h1Val + this.options.step : location;\n          }\n        }\n\n        //this is for single-handled vertical sliders, it adjusts the value to account for the slider being \"upside-down\"\n        //for click and drag events, it's weird due to the scale(-1, 1) css property\n        if (this.options.vertical && !noInvert) {\n          location = this.options.end - location;\n        }\n\n        var _this = this,\n            vert = this.options.vertical,\n            hOrW = vert ? 'height' : 'width',\n            lOrT = vert ? 'top' : 'left',\n            handleDim = $hndl[0].getBoundingClientRect()[hOrW],\n            elemDim = this.$element[0].getBoundingClientRect()[hOrW],\n\n        //percentage of bar min/max value based on click or drag point\n        pctOfBar = percent(location - this.options.start, this.options.end - this.options.start).toFixed(2),\n\n        //number of actual pixels to shift the handle, based on the percentage obtained above\n        pxToMove = (elemDim - handleDim) * pctOfBar,\n\n        //percentage of bar to shift the handle\n        movement = (percent(pxToMove, elemDim) * 100).toFixed(this.options.decimal);\n        //fixing the decimal value for the location number, is passed to other methods as a fixed floating-point value\n        location = parseFloat(location.toFixed(this.options.decimal));\n        // declare empty object for css adjustments, only used with 2 handled-sliders\n        var css = {};\n\n        this._setValues($hndl, location);\n\n        // TODO update to calculate based on values set to respective inputs??\n        if (isDbl) {\n          var isLeftHndl = this.handles.index($hndl) === 0,\n\n          //empty variable, will be used for min-height/width for fill bar\n          dim,\n\n          //percentage w/h of the handle compared to the slider bar\n          handlePct = ~ ~(percent(handleDim, elemDim) * 100);\n          //if left handle, the math is slightly different than if it's the right handle, and the left/top property needs to be changed for the fill bar\n          if (isLeftHndl) {\n            //left or top percentage value to apply to the fill bar.\n            css[lOrT] = movement + '%';\n            //calculate the new min-height/width for the fill bar.\n            dim = parseFloat(this.$handle2[0].style[lOrT]) - movement + handlePct;\n            //this callback is necessary to prevent errors and allow the proper placement and initialization of a 2-handled slider\n            //plus, it means we don't care if 'dim' isNaN on init, it won't be in the future.\n            if (cb && typeof cb === 'function') {\n              cb();\n            } //this is only needed for the initialization of 2 handled sliders\n          } else {\n              //just caching the value of the left/bottom handle's left/top property\n              var handlePos = parseFloat(this.$handle[0].style[lOrT]);\n              //calculate the new min-height/width for the fill bar. Use isNaN to prevent false positives for numbers <= 0\n              //based on the percentage of movement of the handle being manipulated, less the opposing handle's left/top position, plus the percentage w/h of the handle itself\n              dim = movement - (isNaN(handlePos) ? this.options.initialStart / ((this.options.end - this.options.start) / 100) : handlePos) + handlePct;\n            }\n          // assign the min-height/width to our css object\n          css['min-' + hOrW] = dim + '%';\n        }\n\n        this.$element.one('finished.zf.animate', function () {\n          /**\n           * Fires when the handle is done moving.\n           * @event Slider#moved\n           */\n          _this.$element.trigger('moved.zf.slider', [$hndl]);\n        });\n\n        //because we don't know exactly how the handle will be moved, check the amount of time it should take to move.\n        var moveTime = this.$element.data('dragging') ? 1000 / 60 : this.options.moveTime;\n\n        Foundation.Move(moveTime, $hndl, function () {\n          //adjusting the left/top property of the handle, based on the percentage calculated above\n          $hndl.css(lOrT, movement + '%');\n\n          if (!_this.options.doubleSided) {\n            //if single-handled, a simple method to expand the fill bar\n            _this.$fill.css(hOrW, pctOfBar * 100 + '%');\n          } else {\n            //otherwise, use the css object we created above\n            _this.$fill.css(css);\n          }\n        });\n\n        /**\n         * Fires when the value has not been change for a given time.\n         * @event Slider#changed\n         */\n        clearTimeout(_this.timeout);\n        _this.timeout = setTimeout(function () {\n          _this.$element.trigger('changed.zf.slider', [$hndl]);\n        }, _this.options.changedDelay);\n      }\n\n      /**\n       * Sets the initial attribute for the slider element.\n       * @function\n       * @private\n       * @param {Number} idx - index of the current handle/input to use.\n       */\n\n    }, {\n      key: '_setInitAttr',\n      value: function _setInitAttr(idx) {\n        var id = this.inputs.eq(idx).attr('id') || Foundation.GetYoDigits(6, 'slider');\n        this.inputs.eq(idx).attr({\n          'id': id,\n          'max': this.options.end,\n          'min': this.options.start,\n          'step': this.options.step\n        });\n        this.handles.eq(idx).attr({\n          'role': 'slider',\n          'aria-controls': id,\n          'aria-valuemax': this.options.end,\n          'aria-valuemin': this.options.start,\n          'aria-valuenow': idx === 0 ? this.options.initialStart : this.options.initialEnd,\n          'aria-orientation': this.options.vertical ? 'vertical' : 'horizontal',\n          'tabindex': 0\n        });\n      }\n\n      /**\n       * Sets the input and `aria-valuenow` values for the slider element.\n       * @function\n       * @private\n       * @param {jQuery} $handle - the currently selected handle.\n       * @param {Number} val - floating point of the new value.\n       */\n\n    }, {\n      key: '_setValues',\n      value: function _setValues($handle, val) {\n        var idx = this.options.doubleSided ? this.handles.index($handle) : 0;\n        this.inputs.eq(idx).val(val);\n        $handle.attr('aria-valuenow', val);\n      }\n\n      /**\n       * Handles events on the slider element.\n       * Calculates the new location of the current handle.\n       * If there are two handles and the bar was clicked, it determines which handle to move.\n       * @function\n       * @private\n       * @param {Object} e - the `event` object passed from the listener.\n       * @param {jQuery} $handle - the current handle to calculate for, if selected.\n       * @param {Number} val - floating point number for the new value of the slider.\n       * TODO clean this up, there's a lot of repeated code between this and the _setHandlePos fn.\n       */\n\n    }, {\n      key: '_handleEvent',\n      value: function _handleEvent(e, $handle, val) {\n        var value, hasVal;\n        if (!val) {\n          //click or drag events\n          e.preventDefault();\n          var _this = this,\n              vertical = this.options.vertical,\n              param = vertical ? 'height' : 'width',\n              direction = vertical ? 'top' : 'left',\n              eventOffset = vertical ? e.pageY : e.pageX,\n              halfOfHandle = this.$handle[0].getBoundingClientRect()[param] / 2,\n              barDim = this.$element[0].getBoundingClientRect()[param],\n              windowScroll = vertical ? $(window).scrollTop() : $(window).scrollLeft();\n\n          var elemOffset = this.$element.offset()[direction];\n\n          // touch events emulated by the touch util give position relative to screen, add window.scroll to event coordinates...\n          // best way to guess this is simulated is if clientY == pageY\n          if (e.clientY === e.pageY) {\n            eventOffset = eventOffset + windowScroll;\n          }\n          var eventFromBar = eventOffset - elemOffset;\n          var barXY;\n          if (eventFromBar < 0) {\n            barXY = 0;\n          } else if (eventFromBar > barDim) {\n            barXY = barDim;\n          } else {\n            barXY = eventFromBar;\n          }\n          offsetPct = percent(barXY, barDim);\n\n          value = (this.options.end - this.options.start) * offsetPct + this.options.start;\n\n          // turn everything around for RTL, yay math!\n          if (Foundation.rtl() && !this.options.vertical) {\n            value = this.options.end - value;\n          }\n\n          value = _this._adjustValue(null, value);\n          //boolean flag for the setHandlePos fn, specifically for vertical sliders\n          hasVal = false;\n\n          if (!$handle) {\n            //figure out which handle it is, pass it to the next function.\n            var firstHndlPos = absPosition(this.$handle, direction, barXY, param),\n                secndHndlPos = absPosition(this.$handle2, direction, barXY, param);\n            $handle = firstHndlPos <= secndHndlPos ? this.$handle : this.$handle2;\n          }\n        } else {\n          //change event on input\n          value = this._adjustValue(null, val);\n          hasVal = true;\n        }\n\n        this._setHandlePos($handle, value, hasVal);\n      }\n\n      /**\n       * Adjustes value for handle in regard to step value. returns adjusted value\n       * @function\n       * @private\n       * @param {jQuery} $handle - the selected handle.\n       * @param {Number} value - value to adjust. used if $handle is falsy\n       */\n\n    }, {\n      key: '_adjustValue',\n      value: function _adjustValue($handle, value) {\n        var val,\n            step = this.options.step,\n            div = parseFloat(step / 2),\n            left,\n            prev_val,\n            next_val;\n        if (!!$handle) {\n          val = parseFloat($handle.attr('aria-valuenow'));\n        } else {\n          val = value;\n        }\n        left = val % step;\n        prev_val = val - left;\n        next_val = prev_val + step;\n        if (left === 0) {\n          return val;\n        }\n        val = val >= prev_val + div ? next_val : prev_val;\n        return val;\n      }\n\n      /**\n       * Adds event listeners to the slider elements.\n       * @function\n       * @private\n       * @param {jQuery} $handle - the current handle to apply listeners to.\n       */\n\n    }, {\n      key: '_events',\n      value: function _events($handle) {\n        var _this = this,\n            curHandle,\n            timer;\n\n        this.inputs.off('change.zf.slider').on('change.zf.slider', function (e) {\n          var idx = _this.inputs.index($(this));\n          _this._handleEvent(e, _this.handles.eq(idx), $(this).val());\n        });\n\n        if (this.options.clickSelect) {\n          this.$element.off('click.zf.slider').on('click.zf.slider', function (e) {\n            if (_this.$element.data('dragging')) {\n              return false;\n            }\n\n            if (!$(e.target).is('[data-slider-handle]')) {\n              if (_this.options.doubleSided) {\n                _this._handleEvent(e);\n              } else {\n                _this._handleEvent(e, _this.$handle);\n              }\n            }\n          });\n        }\n\n        if (this.options.draggable) {\n          this.handles.addTouch();\n\n          var $body = $('body');\n          $handle.off('mousedown.zf.slider').on('mousedown.zf.slider', function (e) {\n            $handle.addClass('is-dragging');\n            _this.$fill.addClass('is-dragging'); //\n            _this.$element.data('dragging', true);\n\n            curHandle = $(e.currentTarget);\n\n            $body.on('mousemove.zf.slider', function (e) {\n              e.preventDefault();\n              _this._handleEvent(e, curHandle);\n            }).on('mouseup.zf.slider', function (e) {\n              _this._handleEvent(e, curHandle);\n\n              $handle.removeClass('is-dragging');\n              _this.$fill.removeClass('is-dragging');\n              _this.$element.data('dragging', false);\n\n              $body.off('mousemove.zf.slider mouseup.zf.slider');\n            });\n          })\n          // prevent events triggered by touch\n          .on('selectstart.zf.slider touchmove.zf.slider', function (e) {\n            e.preventDefault();\n          });\n        }\n\n        $handle.off('keydown.zf.slider').on('keydown.zf.slider', function (e) {\n          var _$handle = $(this),\n              idx = _this.options.doubleSided ? _this.handles.index(_$handle) : 0,\n              oldValue = parseFloat(_this.inputs.eq(idx).val()),\n              newValue;\n\n          // handle keyboard event with keyboard util\n          Foundation.Keyboard.handleKey(e, 'Slider', {\n            decrease: function () {\n              newValue = oldValue - _this.options.step;\n            },\n            increase: function () {\n              newValue = oldValue + _this.options.step;\n            },\n            decrease_fast: function () {\n              newValue = oldValue - _this.options.step * 10;\n            },\n            increase_fast: function () {\n              newValue = oldValue + _this.options.step * 10;\n            },\n            handled: function () {\n              // only set handle pos when event was handled specially\n              e.preventDefault();\n              _this._setHandlePos(_$handle, newValue, true);\n            }\n          });\n          /*if (newValue) { // if pressed key has special function, update value\n            e.preventDefault();\n            _this._setHandlePos(_$handle, newValue);\n          }*/\n        });\n      }\n\n      /**\n       * Destroys the slider plugin.\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.handles.off('.zf.slider');\n        this.inputs.off('.zf.slider');\n        this.$element.off('.zf.slider');\n\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return Slider;\n  }();\n\n  Slider.defaults = {\n    /**\n     * Minimum value for the slider scale.\n     * @option\n     * @example 0\n     */\n    start: 0,\n    /**\n     * Maximum value for the slider scale.\n     * @option\n     * @example 100\n     */\n    end: 100,\n    /**\n     * Minimum value change per change event.\n     * @option\n     * @example 1\n     */\n    step: 1,\n    /**\n     * Value at which the handle/input *(left handle/first input)* should be set to on initialization.\n     * @option\n     * @example 0\n     */\n    initialStart: 0,\n    /**\n     * Value at which the right handle/second input should be set to on initialization.\n     * @option\n     * @example 100\n     */\n    initialEnd: 100,\n    /**\n     * Allows the input to be located outside the container and visible. Set to by the JS\n     * @option\n     * @example false\n     */\n    binding: false,\n    /**\n     * Allows the user to click/tap on the slider bar to select a value.\n     * @option\n     * @example true\n     */\n    clickSelect: true,\n    /**\n     * Set to true and use the `vertical` class to change alignment to vertical.\n     * @option\n     * @example false\n     */\n    vertical: false,\n    /**\n     * Allows the user to drag the slider handle(s) to select a value.\n     * @option\n     * @example true\n     */\n    draggable: true,\n    /**\n     * Disables the slider and prevents event listeners from being applied. Double checked by JS with `disabledClass`.\n     * @option\n     * @example false\n     */\n    disabled: false,\n    /**\n     * Allows the use of two handles. Double checked by the JS. Changes some logic handling.\n     * @option\n     * @example false\n     */\n    doubleSided: false,\n    /**\n     * Potential future feature.\n     */\n    // steps: 100,\n    /**\n     * Number of decimal places the plugin should go to for floating point precision.\n     * @option\n     * @example 2\n     */\n    decimal: 2,\n    /**\n     * Time delay for dragged elements.\n     */\n    // dragDelay: 0,\n    /**\n     * Time, in ms, to animate the movement of a slider handle if user clicks/taps on the bar. Needs to be manually set if updating the transition time in the Sass settings.\n     * @option\n     * @example 200\n     */\n    moveTime: 200, //update this if changing the transition time in the sass\n    /**\n     * Class applied to disabled sliders.\n     * @option\n     * @example 'disabled'\n     */\n    disabledClass: 'disabled',\n    /**\n     * Will invert the default layout for a vertical<span data-tooltip title=\"who would do this???\"> </span>slider.\n     * @option\n     * @example false\n     */\n    invertVertical: false,\n    /**\n     * Milliseconds before the `changed.zf-slider` event is triggered after value change.\n     * @option\n     * @example 500\n     */\n    changedDelay: 500\n  };\n\n  function percent(frac, num) {\n    return frac / num;\n  }\n  function absPosition($handle, dir, clickPos, param) {\n    return Math.abs($handle.position()[dir] + $handle[param]() / 2 - clickPos);\n  }\n\n  // Window exports\n  Foundation.plugin(Slider, 'Slider');\n}(jQuery);\n\n//*********this is in case we go to static, absolute positions instead of dynamic positioning********\n// this.setSteps(function() {\n//   _this._events();\n//   var initStart = _this.options.positions[_this.options.initialStart - 1] || null;\n//   var initEnd = _this.options.initialEnd ? _this.options.position[_this.options.initialEnd - 1] : null;\n//   if (initStart || initEnd) {\n//     _this._handleEvent(initStart, initEnd);\n//   }\n// });\n\n//***********the other part of absolute positions*************\n// Slider.prototype.setSteps = function(cb) {\n//   var posChange = this.$element.outerWidth() / this.options.steps;\n//   var counter = 0\n//   while(counter < this.options.steps) {\n//     if (counter) {\n//       this.options.positions.push(this.options.positions[counter - 1] + posChange);\n//     } else {\n//       this.options.positions.push(posChange);\n//     }\n//     counter++;\n//   }\n//   cb();\n// };"]},"hash":"954b0450027d0d0633c08437952a8a5704d83b4a"}
