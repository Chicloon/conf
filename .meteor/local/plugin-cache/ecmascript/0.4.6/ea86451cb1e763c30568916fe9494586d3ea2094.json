{"metadata":{"usedHelpers":["classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/zurb:foundation-sites/js/foundation.slider.js","filenameRelative":"/packages/zurb:foundation-sites/js/foundation.slider.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/zurb:foundation-sites/js/foundation.slider.js.map","sourceFileName":"/packages/zurb:foundation-sites/js/foundation.slider.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"foundation.slider"},"ignored":false,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n!function ($) {\n\n  /**\n   * Slider module.\n   * @module foundation.slider\n   * @requires foundation.util.motion\n   * @requires foundation.util.triggers\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.touch\n   */\n\n  var Slider = function () {\n    /**\n     * Creates a new instance of a drilldown menu.\n     * @class\n     * @param {jQuery} element - jQuery object to make into an accordion menu.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n\n    function Slider(element, options) {\n      (0, _classCallCheck3['default'])(this, Slider);\n\n      this.$element = element;\n      this.options = $.extend({}, Slider.defaults, this.$element.data(), options);\n\n      this._init();\n\n      Foundation.registerPlugin(this, 'Slider');\n      Foundation.Keyboard.register('Slider', {\n        'ltr': {\n          'ARROW_RIGHT': 'increase',\n          'ARROW_UP': 'increase',\n          'ARROW_DOWN': 'decrease',\n          'ARROW_LEFT': 'decrease',\n          'SHIFT_ARROW_RIGHT': 'increase_fast',\n          'SHIFT_ARROW_UP': 'increase_fast',\n          'SHIFT_ARROW_DOWN': 'decrease_fast',\n          'SHIFT_ARROW_LEFT': 'decrease_fast'\n        },\n        'rtl': {\n          'ARROW_LEFT': 'increase',\n          'ARROW_RIGHT': 'decrease',\n          'SHIFT_ARROW_LEFT': 'increase_fast',\n          'SHIFT_ARROW_RIGHT': 'decrease_fast'\n        }\n      });\n    }\n\n    /**\n     * Initilizes the plugin by reading/setting attributes, creating collections and setting the initial position of the handle(s).\n     * @function\n     * @private\n     */\n\n\n    Slider.prototype._init = function () {\n      function _init() {\n        this.inputs = this.$element.find('input');\n        this.handles = this.$element.find('[data-slider-handle]');\n\n        this.$handle = this.handles.eq(0);\n        this.$input = this.inputs.length ? this.inputs.eq(0) : $('#' + this.$handle.attr('aria-controls'));\n        this.$fill = this.$element.find('[data-slider-fill]').css(this.options.vertical ? 'height' : 'width', 0);\n\n        var isDbl = false,\n            _this = this;\n        if (this.options.disabled || this.$element.hasClass(this.options.disabledClass)) {\n          this.options.disabled = true;\n          this.$element.addClass(this.options.disabledClass);\n        }\n        if (!this.inputs.length) {\n          this.inputs = $().add(this.$input);\n          this.options.binding = true;\n        }\n        this._setInitAttr(0);\n        this._events(this.$handle);\n\n        if (this.handles[1]) {\n          this.options.doubleSided = true;\n          this.$handle2 = this.handles.eq(1);\n          this.$input2 = this.inputs.length > 1 ? this.inputs.eq(1) : $('#' + this.$handle2.attr('aria-controls'));\n\n          if (!this.inputs[1]) {\n            this.inputs = this.inputs.add(this.$input2);\n          }\n          isDbl = true;\n\n          this._setHandlePos(this.$handle, this.options.initialStart, true, function () {\n\n            _this._setHandlePos(_this.$handle2, _this.options.initialEnd, true);\n          });\n          // this.$handle.triggerHandler('click.zf.slider');\n          this._setInitAttr(1);\n          this._events(this.$handle2);\n        }\n\n        if (!isDbl) {\n          this._setHandlePos(this.$handle, this.options.initialStart, true);\n        }\n      }\n\n      return _init;\n    }();\n\n    /**\n     * Sets the position of the selected handle and fill bar.\n     * @function\n     * @private\n     * @param {jQuery} $hndl - the selected handle to move.\n     * @param {Number} location - floating point between the start and end values of the slider bar.\n     * @param {Function} cb - callback function to fire on completion.\n     * @fires Slider#moved\n     * @fires Slider#changed\n     */\n\n\n    Slider.prototype._setHandlePos = function () {\n      function _setHandlePos($hndl, location, noInvert, cb) {\n        // don't move if the slider has been disabled since its initialization\n        if (this.$element.hasClass(this.options.disabledClass)) {\n          return;\n        }\n        //might need to alter that slightly for bars that will have odd number selections.\n        location = parseFloat(location); //on input change events, convert string to number...grumble.\n\n        // prevent slider from running out of bounds, if value exceeds the limits set through options, override the value to min/max\n        if (location < this.options.start) {\n          location = this.options.start;\n        } else if (location > this.options.end) {\n          location = this.options.end;\n        }\n\n        var isDbl = this.options.doubleSided;\n\n        if (isDbl) {\n          //this block is to prevent 2 handles from crossing eachother. Could/should be improved.\n          if (this.handles.index($hndl) === 0) {\n            var h2Val = parseFloat(this.$handle2.attr('aria-valuenow'));\n            location = location >= h2Val ? h2Val - this.options.step : location;\n          } else {\n            var h1Val = parseFloat(this.$handle.attr('aria-valuenow'));\n            location = location <= h1Val ? h1Val + this.options.step : location;\n          }\n        }\n\n        //this is for single-handled vertical sliders, it adjusts the value to account for the slider being \"upside-down\"\n        //for click and drag events, it's weird due to the scale(-1, 1) css property\n        if (this.options.vertical && !noInvert) {\n          location = this.options.end - location;\n        }\n\n        var _this = this,\n            vert = this.options.vertical,\n            hOrW = vert ? 'height' : 'width',\n            lOrT = vert ? 'top' : 'left',\n            handleDim = $hndl[0].getBoundingClientRect()[hOrW],\n            elemDim = this.$element[0].getBoundingClientRect()[hOrW],\n\n        //percentage of bar min/max value based on click or drag point\n        pctOfBar = percent(location - this.options.start, this.options.end - this.options.start).toFixed(2),\n\n        //number of actual pixels to shift the handle, based on the percentage obtained above\n        pxToMove = (elemDim - handleDim) * pctOfBar,\n\n        //percentage of bar to shift the handle\n        movement = (percent(pxToMove, elemDim) * 100).toFixed(this.options.decimal);\n        //fixing the decimal value for the location number, is passed to other methods as a fixed floating-point value\n        location = parseFloat(location.toFixed(this.options.decimal));\n        // declare empty object for css adjustments, only used with 2 handled-sliders\n        var css = {};\n\n        this._setValues($hndl, location);\n\n        // TODO update to calculate based on values set to respective inputs??\n        if (isDbl) {\n          var isLeftHndl = this.handles.index($hndl) === 0,\n\n          //empty variable, will be used for min-height/width for fill bar\n          dim,\n\n          //percentage w/h of the handle compared to the slider bar\n          handlePct = ~~(percent(handleDim, elemDim) * 100);\n          //if left handle, the math is slightly different than if it's the right handle, and the left/top property needs to be changed for the fill bar\n          if (isLeftHndl) {\n            //left or top percentage value to apply to the fill bar.\n            css[lOrT] = movement + '%';\n            //calculate the new min-height/width for the fill bar.\n            dim = parseFloat(this.$handle2[0].style[lOrT]) - movement + handlePct;\n            //this callback is necessary to prevent errors and allow the proper placement and initialization of a 2-handled slider\n            //plus, it means we don't care if 'dim' isNaN on init, it won't be in the future.\n            if (cb && typeof cb === 'function') {\n              cb();\n            } //this is only needed for the initialization of 2 handled sliders\n          } else {\n              //just caching the value of the left/bottom handle's left/top property\n              var handlePos = parseFloat(this.$handle[0].style[lOrT]);\n              //calculate the new min-height/width for the fill bar. Use isNaN to prevent false positives for numbers <= 0\n              //based on the percentage of movement of the handle being manipulated, less the opposing handle's left/top position, plus the percentage w/h of the handle itself\n              dim = movement - (isNaN(handlePos) ? this.options.initialStart / ((this.options.end - this.options.start) / 100) : handlePos) + handlePct;\n            }\n          // assign the min-height/width to our css object\n          css['min-' + hOrW] = dim + '%';\n        }\n\n        this.$element.one('finished.zf.animate', function () {\n          /**\n           * Fires when the handle is done moving.\n           * @event Slider#moved\n           */\n          _this.$element.trigger('moved.zf.slider', [$hndl]);\n        });\n\n        //because we don't know exactly how the handle will be moved, check the amount of time it should take to move.\n        var moveTime = this.$element.data('dragging') ? 1000 / 60 : this.options.moveTime;\n\n        Foundation.Move(moveTime, $hndl, function () {\n          //adjusting the left/top property of the handle, based on the percentage calculated above\n          $hndl.css(lOrT, movement + '%');\n\n          if (!_this.options.doubleSided) {\n            //if single-handled, a simple method to expand the fill bar\n            _this.$fill.css(hOrW, pctOfBar * 100 + '%');\n          } else {\n            //otherwise, use the css object we created above\n            _this.$fill.css(css);\n          }\n        });\n\n        /**\n         * Fires when the value has not been change for a given time.\n         * @event Slider#changed\n         */\n        clearTimeout(_this.timeout);\n        _this.timeout = setTimeout(function () {\n          _this.$element.trigger('changed.zf.slider', [$hndl]);\n        }, _this.options.changedDelay);\n      }\n\n      return _setHandlePos;\n    }();\n\n    /**\n     * Sets the initial attribute for the slider element.\n     * @function\n     * @private\n     * @param {Number} idx - index of the current handle/input to use.\n     */\n\n\n    Slider.prototype._setInitAttr = function () {\n      function _setInitAttr(idx) {\n        var id = this.inputs.eq(idx).attr('id') || Foundation.GetYoDigits(6, 'slider');\n        this.inputs.eq(idx).attr({\n          'id': id,\n          'max': this.options.end,\n          'min': this.options.start,\n          'step': this.options.step\n        });\n        this.handles.eq(idx).attr({\n          'role': 'slider',\n          'aria-controls': id,\n          'aria-valuemax': this.options.end,\n          'aria-valuemin': this.options.start,\n          'aria-valuenow': idx === 0 ? this.options.initialStart : this.options.initialEnd,\n          'aria-orientation': this.options.vertical ? 'vertical' : 'horizontal',\n          'tabindex': 0\n        });\n      }\n\n      return _setInitAttr;\n    }();\n\n    /**\n     * Sets the input and `aria-valuenow` values for the slider element.\n     * @function\n     * @private\n     * @param {jQuery} $handle - the currently selected handle.\n     * @param {Number} val - floating point of the new value.\n     */\n\n\n    Slider.prototype._setValues = function () {\n      function _setValues($handle, val) {\n        var idx = this.options.doubleSided ? this.handles.index($handle) : 0;\n        this.inputs.eq(idx).val(val);\n        $handle.attr('aria-valuenow', val);\n      }\n\n      return _setValues;\n    }();\n\n    /**\n     * Handles events on the slider element.\n     * Calculates the new location of the current handle.\n     * If there are two handles and the bar was clicked, it determines which handle to move.\n     * @function\n     * @private\n     * @param {Object} e - the `event` object passed from the listener.\n     * @param {jQuery} $handle - the current handle to calculate for, if selected.\n     * @param {Number} val - floating point number for the new value of the slider.\n     * TODO clean this up, there's a lot of repeated code between this and the _setHandlePos fn.\n     */\n\n\n    Slider.prototype._handleEvent = function () {\n      function _handleEvent(e, $handle, val) {\n        var value, hasVal;\n        if (!val) {\n          //click or drag events\n          e.preventDefault();\n          var _this = this,\n              vertical = this.options.vertical,\n              param = vertical ? 'height' : 'width',\n              direction = vertical ? 'top' : 'left',\n              eventOffset = vertical ? e.pageY : e.pageX,\n              halfOfHandle = this.$handle[0].getBoundingClientRect()[param] / 2,\n              barDim = this.$element[0].getBoundingClientRect()[param],\n              windowScroll = vertical ? $(window).scrollTop() : $(window).scrollLeft();\n\n          var elemOffset = this.$element.offset()[direction];\n\n          // touch events emulated by the touch util give position relative to screen, add window.scroll to event coordinates...\n          // best way to guess this is simulated is if clientY == pageY\n          if (e.clientY === e.pageY) {\n            eventOffset = eventOffset + windowScroll;\n          }\n          var eventFromBar = eventOffset - elemOffset;\n          var barXY;\n          if (eventFromBar < 0) {\n            barXY = 0;\n          } else if (eventFromBar > barDim) {\n            barXY = barDim;\n          } else {\n            barXY = eventFromBar;\n          }\n          offsetPct = percent(barXY, barDim);\n\n          value = (this.options.end - this.options.start) * offsetPct + this.options.start;\n\n          // turn everything around for RTL, yay math!\n          if (Foundation.rtl() && !this.options.vertical) {\n            value = this.options.end - value;\n          }\n\n          value = _this._adjustValue(null, value);\n          //boolean flag for the setHandlePos fn, specifically for vertical sliders\n          hasVal = false;\n\n          if (!$handle) {\n            //figure out which handle it is, pass it to the next function.\n            var firstHndlPos = absPosition(this.$handle, direction, barXY, param),\n                secndHndlPos = absPosition(this.$handle2, direction, barXY, param);\n            $handle = firstHndlPos <= secndHndlPos ? this.$handle : this.$handle2;\n          }\n        } else {\n          //change event on input\n          value = this._adjustValue(null, val);\n          hasVal = true;\n        }\n\n        this._setHandlePos($handle, value, hasVal);\n      }\n\n      return _handleEvent;\n    }();\n\n    /**\n     * Adjustes value for handle in regard to step value. returns adjusted value\n     * @function\n     * @private\n     * @param {jQuery} $handle - the selected handle.\n     * @param {Number} value - value to adjust. used if $handle is falsy\n     */\n\n\n    Slider.prototype._adjustValue = function () {\n      function _adjustValue($handle, value) {\n        var val,\n            step = this.options.step,\n            div = parseFloat(step / 2),\n            left,\n            prev_val,\n            next_val;\n        if (!!$handle) {\n          val = parseFloat($handle.attr('aria-valuenow'));\n        } else {\n          val = value;\n        }\n        left = val % step;\n        prev_val = val - left;\n        next_val = prev_val + step;\n        if (left === 0) {\n          return val;\n        }\n        val = val >= prev_val + div ? next_val : prev_val;\n        return val;\n      }\n\n      return _adjustValue;\n    }();\n\n    /**\n     * Adds event listeners to the slider elements.\n     * @function\n     * @private\n     * @param {jQuery} $handle - the current handle to apply listeners to.\n     */\n\n\n    Slider.prototype._events = function () {\n      function _events($handle) {\n        var _this = this,\n            curHandle,\n            timer;\n\n        this.inputs.off('change.zf.slider').on('change.zf.slider', function (e) {\n          var idx = _this.inputs.index($(this));\n          _this._handleEvent(e, _this.handles.eq(idx), $(this).val());\n        });\n\n        if (this.options.clickSelect) {\n          this.$element.off('click.zf.slider').on('click.zf.slider', function (e) {\n            if (_this.$element.data('dragging')) {\n              return false;\n            }\n\n            if (!$(e.target).is('[data-slider-handle]')) {\n              if (_this.options.doubleSided) {\n                _this._handleEvent(e);\n              } else {\n                _this._handleEvent(e, _this.$handle);\n              }\n            }\n          });\n        }\n\n        if (this.options.draggable) {\n          this.handles.addTouch();\n\n          var $body = $('body');\n          $handle.off('mousedown.zf.slider').on('mousedown.zf.slider', function (e) {\n            $handle.addClass('is-dragging');\n            _this.$fill.addClass('is-dragging'); //\n            _this.$element.data('dragging', true);\n\n            curHandle = $(e.currentTarget);\n\n            $body.on('mousemove.zf.slider', function (e) {\n              e.preventDefault();\n              _this._handleEvent(e, curHandle);\n            }).on('mouseup.zf.slider', function (e) {\n              _this._handleEvent(e, curHandle);\n\n              $handle.removeClass('is-dragging');\n              _this.$fill.removeClass('is-dragging');\n              _this.$element.data('dragging', false);\n\n              $body.off('mousemove.zf.slider mouseup.zf.slider');\n            });\n          })\n          // prevent events triggered by touch\n          .on('selectstart.zf.slider touchmove.zf.slider', function (e) {\n            e.preventDefault();\n          });\n        }\n\n        $handle.off('keydown.zf.slider').on('keydown.zf.slider', function (e) {\n          var _$handle = $(this),\n              idx = _this.options.doubleSided ? _this.handles.index(_$handle) : 0,\n              oldValue = parseFloat(_this.inputs.eq(idx).val()),\n              newValue;\n\n          // handle keyboard event with keyboard util\n          Foundation.Keyboard.handleKey(e, 'Slider', {\n            decrease: function () {\n              function decrease() {\n                newValue = oldValue - _this.options.step;\n              }\n\n              return decrease;\n            }(),\n            increase: function () {\n              function increase() {\n                newValue = oldValue + _this.options.step;\n              }\n\n              return increase;\n            }(),\n            decrease_fast: function () {\n              function decrease_fast() {\n                newValue = oldValue - _this.options.step * 10;\n              }\n\n              return decrease_fast;\n            }(),\n            increase_fast: function () {\n              function increase_fast() {\n                newValue = oldValue + _this.options.step * 10;\n              }\n\n              return increase_fast;\n            }(),\n            handled: function () {\n              function handled() {\n                // only set handle pos when event was handled specially\n                e.preventDefault();\n                _this._setHandlePos(_$handle, newValue, true);\n              }\n\n              return handled;\n            }()\n          });\n          /*if (newValue) { // if pressed key has special function, update value\n            e.preventDefault();\n            _this._setHandlePos(_$handle, newValue);\n          }*/\n        });\n      }\n\n      return _events;\n    }();\n\n    /**\n     * Destroys the slider plugin.\n     */\n\n\n    Slider.prototype.destroy = function () {\n      function destroy() {\n        this.handles.off('.zf.slider');\n        this.inputs.off('.zf.slider');\n        this.$element.off('.zf.slider');\n\n        Foundation.unregisterPlugin(this);\n      }\n\n      return destroy;\n    }();\n\n    return Slider;\n  }();\n\n  Slider.defaults = {\n    /**\n     * Minimum value for the slider scale.\n     * @option\n     * @example 0\n     */\n    start: 0,\n    /**\n     * Maximum value for the slider scale.\n     * @option\n     * @example 100\n     */\n    end: 100,\n    /**\n     * Minimum value change per change event.\n     * @option\n     * @example 1\n     */\n    step: 1,\n    /**\n     * Value at which the handle/input *(left handle/first input)* should be set to on initialization.\n     * @option\n     * @example 0\n     */\n    initialStart: 0,\n    /**\n     * Value at which the right handle/second input should be set to on initialization.\n     * @option\n     * @example 100\n     */\n    initialEnd: 100,\n    /**\n     * Allows the input to be located outside the container and visible. Set to by the JS\n     * @option\n     * @example false\n     */\n    binding: false,\n    /**\n     * Allows the user to click/tap on the slider bar to select a value.\n     * @option\n     * @example true\n     */\n    clickSelect: true,\n    /**\n     * Set to true and use the `vertical` class to change alignment to vertical.\n     * @option\n     * @example false\n     */\n    vertical: false,\n    /**\n     * Allows the user to drag the slider handle(s) to select a value.\n     * @option\n     * @example true\n     */\n    draggable: true,\n    /**\n     * Disables the slider and prevents event listeners from being applied. Double checked by JS with `disabledClass`.\n     * @option\n     * @example false\n     */\n    disabled: false,\n    /**\n     * Allows the use of two handles. Double checked by the JS. Changes some logic handling.\n     * @option\n     * @example false\n     */\n    doubleSided: false,\n    /**\n     * Potential future feature.\n     */\n    // steps: 100,\n    /**\n     * Number of decimal places the plugin should go to for floating point precision.\n     * @option\n     * @example 2\n     */\n    decimal: 2,\n    /**\n     * Time delay for dragged elements.\n     */\n    // dragDelay: 0,\n    /**\n     * Time, in ms, to animate the movement of a slider handle if user clicks/taps on the bar. Needs to be manually set if updating the transition time in the Sass settings.\n     * @option\n     * @example 200\n     */\n    moveTime: 200, //update this if changing the transition time in the sass\n    /**\n     * Class applied to disabled sliders.\n     * @option\n     * @example 'disabled'\n     */\n    disabledClass: 'disabled',\n    /**\n     * Will invert the default layout for a vertical<span data-tooltip title=\"who would do this???\"> </span>slider.\n     * @option\n     * @example false\n     */\n    invertVertical: false,\n    /**\n     * Milliseconds before the `changed.zf-slider` event is triggered after value change.\n     * @option\n     * @example 500\n     */\n    changedDelay: 500\n  };\n\n  function percent(frac, num) {\n    return frac / num;\n  }\n  function absPosition($handle, dir, clickPos, param) {\n    return Math.abs($handle.position()[dir] + $handle[param]() / 2 - clickPos);\n  }\n\n  // Window exports\n  Foundation.plugin(Slider, 'Slider');\n}(jQuery);\n\n//*********this is in case we go to static, absolute positions instead of dynamic positioning********\n// this.setSteps(function() {\n//   _this._events();\n//   var initStart = _this.options.positions[_this.options.initialStart - 1] || null;\n//   var initEnd = _this.options.initialEnd ? _this.options.position[_this.options.initialEnd - 1] : null;\n//   if (initStart || initEnd) {\n//     _this._handleEvent(initStart, initEnd);\n//   }\n// });\n\n//***********the other part of absolute positions*************\n// Slider.prototype.setSteps = function(cb) {\n//   var posChange = this.$element.outerWidth() / this.options.steps;\n//   var counter = 0\n//   while(counter < this.options.steps) {\n//     if (counter) {\n//       this.options.positions.push(this.options.positions[counter - 1] + posChange);\n//     } else {\n//       this.options.positions.push(posChange);\n//     }\n//     counter++;\n//   }\n//   cb();\n// };","ast":null,"map":{"version":3,"sources":["/packages/zurb:foundation-sites/js/foundation.slider.js"],"names":[],"mappings":"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","file":"/packages/zurb:foundation-sites/js/foundation.slider.js.map","sourcesContent":["'use strict';\n\n!function($) {\n\n/**\n * Slider module.\n * @module foundation.slider\n * @requires foundation.util.motion\n * @requires foundation.util.triggers\n * @requires foundation.util.keyboard\n * @requires foundation.util.touch\n */\n\nclass Slider {\n  /**\n   * Creates a new instance of a drilldown menu.\n   * @class\n   * @param {jQuery} element - jQuery object to make into an accordion menu.\n   * @param {Object} options - Overrides to the default plugin settings.\n   */\n  constructor(element, options) {\n    this.$element = element;\n    this.options = $.extend({}, Slider.defaults, this.$element.data(), options);\n\n    this._init();\n\n    Foundation.registerPlugin(this, 'Slider');\n    Foundation.Keyboard.register('Slider', {\n      'ltr': {\n        'ARROW_RIGHT': 'increase',\n        'ARROW_UP': 'increase',\n        'ARROW_DOWN': 'decrease',\n        'ARROW_LEFT': 'decrease',\n        'SHIFT_ARROW_RIGHT': 'increase_fast',\n        'SHIFT_ARROW_UP': 'increase_fast',\n        'SHIFT_ARROW_DOWN': 'decrease_fast',\n        'SHIFT_ARROW_LEFT': 'decrease_fast'\n      },\n      'rtl': {\n        'ARROW_LEFT': 'increase',\n        'ARROW_RIGHT': 'decrease',\n        'SHIFT_ARROW_LEFT': 'increase_fast',\n        'SHIFT_ARROW_RIGHT': 'decrease_fast'\n      }\n    });\n  }\n\n  /**\n   * Initilizes the plugin by reading/setting attributes, creating collections and setting the initial position of the handle(s).\n   * @function\n   * @private\n   */\n  _init() {\n    this.inputs = this.$element.find('input');\n    this.handles = this.$element.find('[data-slider-handle]');\n\n    this.$handle = this.handles.eq(0);\n    this.$input = this.inputs.length ? this.inputs.eq(0) : $(`#${this.$handle.attr('aria-controls')}`);\n    this.$fill = this.$element.find('[data-slider-fill]').css(this.options.vertical ? 'height' : 'width', 0);\n\n    var isDbl = false,\n        _this = this;\n    if (this.options.disabled || this.$element.hasClass(this.options.disabledClass)) {\n      this.options.disabled = true;\n      this.$element.addClass(this.options.disabledClass);\n    }\n    if (!this.inputs.length) {\n      this.inputs = $().add(this.$input);\n      this.options.binding = true;\n    }\n    this._setInitAttr(0);\n    this._events(this.$handle);\n\n    if (this.handles[1]) {\n      this.options.doubleSided = true;\n      this.$handle2 = this.handles.eq(1);\n      this.$input2 = this.inputs.length > 1 ? this.inputs.eq(1) : $(`#${this.$handle2.attr('aria-controls')}`);\n\n      if (!this.inputs[1]) {\n        this.inputs = this.inputs.add(this.$input2);\n      }\n      isDbl = true;\n\n      this._setHandlePos(this.$handle, this.options.initialStart, true, function() {\n\n        _this._setHandlePos(_this.$handle2, _this.options.initialEnd, true);\n      });\n      // this.$handle.triggerHandler('click.zf.slider');\n      this._setInitAttr(1);\n      this._events(this.$handle2);\n    }\n\n    if (!isDbl) {\n      this._setHandlePos(this.$handle, this.options.initialStart, true);\n    }\n  }\n\n  /**\n   * Sets the position of the selected handle and fill bar.\n   * @function\n   * @private\n   * @param {jQuery} $hndl - the selected handle to move.\n   * @param {Number} location - floating point between the start and end values of the slider bar.\n   * @param {Function} cb - callback function to fire on completion.\n   * @fires Slider#moved\n   * @fires Slider#changed\n   */\n  _setHandlePos($hndl, location, noInvert, cb) {\n    // don't move if the slider has been disabled since its initialization\n    if (this.$element.hasClass(this.options.disabledClass)) {\n      return;\n    }\n    //might need to alter that slightly for bars that will have odd number selections.\n    location = parseFloat(location);//on input change events, convert string to number...grumble.\n\n    // prevent slider from running out of bounds, if value exceeds the limits set through options, override the value to min/max\n    if (location < this.options.start) { location = this.options.start; }\n    else if (location > this.options.end) { location = this.options.end; }\n\n    var isDbl = this.options.doubleSided;\n\n    if (isDbl) { //this block is to prevent 2 handles from crossing eachother. Could/should be improved.\n      if (this.handles.index($hndl) === 0) {\n        var h2Val = parseFloat(this.$handle2.attr('aria-valuenow'));\n        location = location >= h2Val ? h2Val - this.options.step : location;\n      } else {\n        var h1Val = parseFloat(this.$handle.attr('aria-valuenow'));\n        location = location <= h1Val ? h1Val + this.options.step : location;\n      }\n    }\n\n    //this is for single-handled vertical sliders, it adjusts the value to account for the slider being \"upside-down\"\n    //for click and drag events, it's weird due to the scale(-1, 1) css property\n    if (this.options.vertical && !noInvert) {\n      location = this.options.end - location;\n    }\n\n    var _this = this,\n        vert = this.options.vertical,\n        hOrW = vert ? 'height' : 'width',\n        lOrT = vert ? 'top' : 'left',\n        handleDim = $hndl[0].getBoundingClientRect()[hOrW],\n        elemDim = this.$element[0].getBoundingClientRect()[hOrW],\n        //percentage of bar min/max value based on click or drag point\n        pctOfBar = percent(location - this.options.start, this.options.end - this.options.start).toFixed(2),\n        //number of actual pixels to shift the handle, based on the percentage obtained above\n        pxToMove = (elemDim - handleDim) * pctOfBar,\n        //percentage of bar to shift the handle\n        movement = (percent(pxToMove, elemDim) * 100).toFixed(this.options.decimal);\n        //fixing the decimal value for the location number, is passed to other methods as a fixed floating-point value\n        location = parseFloat(location.toFixed(this.options.decimal));\n        // declare empty object for css adjustments, only used with 2 handled-sliders\n    var css = {};\n\n    this._setValues($hndl, location);\n\n    // TODO update to calculate based on values set to respective inputs??\n    if (isDbl) {\n      var isLeftHndl = this.handles.index($hndl) === 0,\n          //empty variable, will be used for min-height/width for fill bar\n          dim,\n          //percentage w/h of the handle compared to the slider bar\n          handlePct =  ~~(percent(handleDim, elemDim) * 100);\n      //if left handle, the math is slightly different than if it's the right handle, and the left/top property needs to be changed for the fill bar\n      if (isLeftHndl) {\n        //left or top percentage value to apply to the fill bar.\n        css[lOrT] = `${movement}%`;\n        //calculate the new min-height/width for the fill bar.\n        dim = parseFloat(this.$handle2[0].style[lOrT]) - movement + handlePct;\n        //this callback is necessary to prevent errors and allow the proper placement and initialization of a 2-handled slider\n        //plus, it means we don't care if 'dim' isNaN on init, it won't be in the future.\n        if (cb && typeof cb === 'function') { cb(); }//this is only needed for the initialization of 2 handled sliders\n      } else {\n        //just caching the value of the left/bottom handle's left/top property\n        var handlePos = parseFloat(this.$handle[0].style[lOrT]);\n        //calculate the new min-height/width for the fill bar. Use isNaN to prevent false positives for numbers <= 0\n        //based on the percentage of movement of the handle being manipulated, less the opposing handle's left/top position, plus the percentage w/h of the handle itself\n        dim = movement - (isNaN(handlePos) ? this.options.initialStart/((this.options.end-this.options.start)/100) : handlePos) + handlePct;\n      }\n      // assign the min-height/width to our css object\n      css[`min-${hOrW}`] = `${dim}%`;\n    }\n\n    this.$element.one('finished.zf.animate', function() {\n                    /**\n                     * Fires when the handle is done moving.\n                     * @event Slider#moved\n                     */\n                    _this.$element.trigger('moved.zf.slider', [$hndl]);\n                });\n\n    //because we don't know exactly how the handle will be moved, check the amount of time it should take to move.\n    var moveTime = this.$element.data('dragging') ? 1000/60 : this.options.moveTime;\n\n    Foundation.Move(moveTime, $hndl, function() {\n      //adjusting the left/top property of the handle, based on the percentage calculated above\n      $hndl.css(lOrT, `${movement}%`);\n\n      if (!_this.options.doubleSided) {\n        //if single-handled, a simple method to expand the fill bar\n        _this.$fill.css(hOrW, `${pctOfBar * 100}%`);\n      } else {\n        //otherwise, use the css object we created above\n        _this.$fill.css(css);\n      }\n    });\n\n    /**\n     * Fires when the value has not been change for a given time.\n     * @event Slider#changed\n     */\n    clearTimeout(_this.timeout);\n    _this.timeout = setTimeout(function(){\n      _this.$element.trigger('changed.zf.slider', [$hndl]);\n    }, _this.options.changedDelay);\n  }\n\n  /**\n   * Sets the initial attribute for the slider element.\n   * @function\n   * @private\n   * @param {Number} idx - index of the current handle/input to use.\n   */\n  _setInitAttr(idx) {\n    var id = this.inputs.eq(idx).attr('id') || Foundation.GetYoDigits(6, 'slider');\n    this.inputs.eq(idx).attr({\n      'id': id,\n      'max': this.options.end,\n      'min': this.options.start,\n      'step': this.options.step\n    });\n    this.handles.eq(idx).attr({\n      'role': 'slider',\n      'aria-controls': id,\n      'aria-valuemax': this.options.end,\n      'aria-valuemin': this.options.start,\n      'aria-valuenow': idx === 0 ? this.options.initialStart : this.options.initialEnd,\n      'aria-orientation': this.options.vertical ? 'vertical' : 'horizontal',\n      'tabindex': 0\n    });\n  }\n\n  /**\n   * Sets the input and `aria-valuenow` values for the slider element.\n   * @function\n   * @private\n   * @param {jQuery} $handle - the currently selected handle.\n   * @param {Number} val - floating point of the new value.\n   */\n  _setValues($handle, val) {\n    var idx = this.options.doubleSided ? this.handles.index($handle) : 0;\n    this.inputs.eq(idx).val(val);\n    $handle.attr('aria-valuenow', val);\n  }\n\n  /**\n   * Handles events on the slider element.\n   * Calculates the new location of the current handle.\n   * If there are two handles and the bar was clicked, it determines which handle to move.\n   * @function\n   * @private\n   * @param {Object} e - the `event` object passed from the listener.\n   * @param {jQuery} $handle - the current handle to calculate for, if selected.\n   * @param {Number} val - floating point number for the new value of the slider.\n   * TODO clean this up, there's a lot of repeated code between this and the _setHandlePos fn.\n   */\n  _handleEvent(e, $handle, val) {\n    var value, hasVal;\n    if (!val) {//click or drag events\n      e.preventDefault();\n      var _this = this,\n          vertical = this.options.vertical,\n          param = vertical ? 'height' : 'width',\n          direction = vertical ? 'top' : 'left',\n          eventOffset = vertical ? e.pageY : e.pageX,\n          halfOfHandle = this.$handle[0].getBoundingClientRect()[param] / 2,\n          barDim = this.$element[0].getBoundingClientRect()[param],\n          windowScroll = vertical ? $(window).scrollTop() : $(window).scrollLeft();\n\n\n      var elemOffset = this.$element.offset()[direction];\n\n      // touch events emulated by the touch util give position relative to screen, add window.scroll to event coordinates...\n      // best way to guess this is simulated is if clientY == pageY\n      if (e.clientY === e.pageY) { eventOffset = eventOffset + windowScroll; }\n      var eventFromBar = eventOffset - elemOffset;\n      var barXY;\n      if (eventFromBar < 0) {\n        barXY = 0;\n      } else if (eventFromBar > barDim) {\n        barXY = barDim;\n      } else {\n        barXY = eventFromBar;\n      }\n      offsetPct = percent(barXY, barDim);\n\n      value = (this.options.end - this.options.start) * offsetPct + this.options.start;\n\n      // turn everything around for RTL, yay math!\n      if (Foundation.rtl() && !this.options.vertical) {value = this.options.end - value;}\n\n      value = _this._adjustValue(null, value);\n      //boolean flag for the setHandlePos fn, specifically for vertical sliders\n      hasVal = false;\n\n      if (!$handle) {//figure out which handle it is, pass it to the next function.\n        var firstHndlPos = absPosition(this.$handle, direction, barXY, param),\n            secndHndlPos = absPosition(this.$handle2, direction, barXY, param);\n            $handle = firstHndlPos <= secndHndlPos ? this.$handle : this.$handle2;\n      }\n\n    } else {//change event on input\n      value = this._adjustValue(null, val);\n      hasVal = true;\n    }\n\n    this._setHandlePos($handle, value, hasVal);\n  }\n\n  /**\n   * Adjustes value for handle in regard to step value. returns adjusted value\n   * @function\n   * @private\n   * @param {jQuery} $handle - the selected handle.\n   * @param {Number} value - value to adjust. used if $handle is falsy\n   */\n  _adjustValue($handle, value) {\n    var val,\n      step = this.options.step,\n      div = parseFloat(step/2),\n      left, prev_val, next_val;\n    if (!!$handle) {\n      val = parseFloat($handle.attr('aria-valuenow'));\n    }\n    else {\n      val = value;\n    }\n    left = val % step;\n    prev_val = val - left;\n    next_val = prev_val + step;\n    if (left === 0) {\n      return val;\n    }\n    val = val >= prev_val + div ? next_val : prev_val;\n    return val;\n  }\n\n  /**\n   * Adds event listeners to the slider elements.\n   * @function\n   * @private\n   * @param {jQuery} $handle - the current handle to apply listeners to.\n   */\n  _events($handle) {\n    var _this = this,\n        curHandle,\n        timer;\n\n      this.inputs.off('change.zf.slider').on('change.zf.slider', function(e) {\n        var idx = _this.inputs.index($(this));\n        _this._handleEvent(e, _this.handles.eq(idx), $(this).val());\n      });\n\n      if (this.options.clickSelect) {\n        this.$element.off('click.zf.slider').on('click.zf.slider', function(e) {\n          if (_this.$element.data('dragging')) { return false; }\n\n          if (!$(e.target).is('[data-slider-handle]')) {\n            if (_this.options.doubleSided) {\n              _this._handleEvent(e);\n            } else {\n              _this._handleEvent(e, _this.$handle);\n            }\n          }\n        });\n      }\n\n    if (this.options.draggable) {\n      this.handles.addTouch();\n\n      var $body = $('body');\n      $handle\n        .off('mousedown.zf.slider')\n        .on('mousedown.zf.slider', function(e) {\n          $handle.addClass('is-dragging');\n          _this.$fill.addClass('is-dragging');//\n          _this.$element.data('dragging', true);\n\n          curHandle = $(e.currentTarget);\n\n          $body.on('mousemove.zf.slider', function(e) {\n            e.preventDefault();\n            _this._handleEvent(e, curHandle);\n\n          }).on('mouseup.zf.slider', function(e) {\n            _this._handleEvent(e, curHandle);\n\n            $handle.removeClass('is-dragging');\n            _this.$fill.removeClass('is-dragging');\n            _this.$element.data('dragging', false);\n\n            $body.off('mousemove.zf.slider mouseup.zf.slider');\n          });\n      })\n      // prevent events triggered by touch\n      .on('selectstart.zf.slider touchmove.zf.slider', function(e) {\n        e.preventDefault();\n      });\n    }\n\n    $handle.off('keydown.zf.slider').on('keydown.zf.slider', function(e) {\n      var _$handle = $(this),\n          idx = _this.options.doubleSided ? _this.handles.index(_$handle) : 0,\n          oldValue = parseFloat(_this.inputs.eq(idx).val()),\n          newValue;\n\n      // handle keyboard event with keyboard util\n      Foundation.Keyboard.handleKey(e, 'Slider', {\n        decrease: function() {\n          newValue = oldValue - _this.options.step;\n        },\n        increase: function() {\n          newValue = oldValue + _this.options.step;\n        },\n        decrease_fast: function() {\n          newValue = oldValue - _this.options.step * 10;\n        },\n        increase_fast: function() {\n          newValue = oldValue + _this.options.step * 10;\n        },\n        handled: function() { // only set handle pos when event was handled specially\n          e.preventDefault();\n          _this._setHandlePos(_$handle, newValue, true);\n        }\n      });\n      /*if (newValue) { // if pressed key has special function, update value\n        e.preventDefault();\n        _this._setHandlePos(_$handle, newValue);\n      }*/\n    });\n  }\n\n  /**\n   * Destroys the slider plugin.\n   */\n  destroy() {\n    this.handles.off('.zf.slider');\n    this.inputs.off('.zf.slider');\n    this.$element.off('.zf.slider');\n\n    Foundation.unregisterPlugin(this);\n  }\n}\n\nSlider.defaults = {\n  /**\n   * Minimum value for the slider scale.\n   * @option\n   * @example 0\n   */\n  start: 0,\n  /**\n   * Maximum value for the slider scale.\n   * @option\n   * @example 100\n   */\n  end: 100,\n  /**\n   * Minimum value change per change event.\n   * @option\n   * @example 1\n   */\n  step: 1,\n  /**\n   * Value at which the handle/input *(left handle/first input)* should be set to on initialization.\n   * @option\n   * @example 0\n   */\n  initialStart: 0,\n  /**\n   * Value at which the right handle/second input should be set to on initialization.\n   * @option\n   * @example 100\n   */\n  initialEnd: 100,\n  /**\n   * Allows the input to be located outside the container and visible. Set to by the JS\n   * @option\n   * @example false\n   */\n  binding: false,\n  /**\n   * Allows the user to click/tap on the slider bar to select a value.\n   * @option\n   * @example true\n   */\n  clickSelect: true,\n  /**\n   * Set to true and use the `vertical` class to change alignment to vertical.\n   * @option\n   * @example false\n   */\n  vertical: false,\n  /**\n   * Allows the user to drag the slider handle(s) to select a value.\n   * @option\n   * @example true\n   */\n  draggable: true,\n  /**\n   * Disables the slider and prevents event listeners from being applied. Double checked by JS with `disabledClass`.\n   * @option\n   * @example false\n   */\n  disabled: false,\n  /**\n   * Allows the use of two handles. Double checked by the JS. Changes some logic handling.\n   * @option\n   * @example false\n   */\n  doubleSided: false,\n  /**\n   * Potential future feature.\n   */\n  // steps: 100,\n  /**\n   * Number of decimal places the plugin should go to for floating point precision.\n   * @option\n   * @example 2\n   */\n  decimal: 2,\n  /**\n   * Time delay for dragged elements.\n   */\n  // dragDelay: 0,\n  /**\n   * Time, in ms, to animate the movement of a slider handle if user clicks/taps on the bar. Needs to be manually set if updating the transition time in the Sass settings.\n   * @option\n   * @example 200\n   */\n  moveTime: 200,//update this if changing the transition time in the sass\n  /**\n   * Class applied to disabled sliders.\n   * @option\n   * @example 'disabled'\n   */\n  disabledClass: 'disabled',\n  /**\n   * Will invert the default layout for a vertical<span data-tooltip title=\"who would do this???\"> </span>slider.\n   * @option\n   * @example false\n   */\n  invertVertical: false,\n  /**\n   * Milliseconds before the `changed.zf-slider` event is triggered after value change.\n   * @option\n   * @example 500\n   */\n  changedDelay: 500\n};\n\nfunction percent(frac, num) {\n  return (frac / num);\n}\nfunction absPosition($handle, dir, clickPos, param) {\n  return Math.abs(($handle.position()[dir] + ($handle[param]() / 2)) - clickPos);\n}\n\n// Window exports\nFoundation.plugin(Slider, 'Slider');\n\n}(jQuery);\n\n//*********this is in case we go to static, absolute positions instead of dynamic positioning********\n// this.setSteps(function() {\n//   _this._events();\n//   var initStart = _this.options.positions[_this.options.initialStart - 1] || null;\n//   var initEnd = _this.options.initialEnd ? _this.options.position[_this.options.initialEnd - 1] : null;\n//   if (initStart || initEnd) {\n//     _this._handleEvent(initStart, initEnd);\n//   }\n// });\n\n//***********the other part of absolute positions*************\n// Slider.prototype.setSteps = function(cb) {\n//   var posChange = this.$element.outerWidth() / this.options.steps;\n//   var counter = 0\n//   while(counter < this.options.steps) {\n//     if (counter) {\n//       this.options.positions.push(this.options.positions[counter - 1] + posChange);\n//     } else {\n//       this.options.positions.push(posChange);\n//     }\n//     counter++;\n//   }\n//   cb();\n// };\n"]},"hash":"ea86451cb1e763c30568916fe9494586d3ea2094"}
