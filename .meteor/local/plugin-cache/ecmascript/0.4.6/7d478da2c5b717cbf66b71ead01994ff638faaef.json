{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/zurb:foundation-sites/vendor/jquery/src/callbacks.js","filenameRelative":"/packages/zurb:foundation-sites/vendor/jquery/src/callbacks.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/zurb:foundation-sites/vendor/jquery/src/callbacks.js.map","sourceFileName":"/packages/zurb:foundation-sites/vendor/jquery/src/callbacks.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"callbacks"},"ignored":false,"code":"define([\"./core\", \"./var/rnotwhite\"], function (jQuery, rnotwhite) {\n\n\t// Convert String-formatted options into Object-formatted ones\n\tfunction createOptions(options) {\n\t\tvar object = {};\n\t\tjQuery.each(options.match(rnotwhite) || [], function (_, flag) {\n\t\t\tobject[flag] = true;\n\t\t});\n\t\treturn object;\n\t}\n\n\t/*\n  * Create a callback list using the following parameters:\n  *\n  *\toptions: an optional list of space-separated options that will change how\n  *\t\t\tthe callback list behaves or a more traditional option object\n  *\n  * By default a callback list will act like an event callback list and can be\n  * \"fired\" multiple times.\n  *\n  * Possible options:\n  *\n  *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n  *\n  *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n  *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n  *\t\t\t\t\tvalues (like a Deferred)\n  *\n  *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n  *\n  *\tstopOnFalse:\tinterrupt callings when a callback returns false\n  *\n  */\n\tjQuery.Callbacks = function (options) {\n\n\t\t// Convert options from String-formatted to Object-formatted if needed\n\t\t// (we check in cache first)\n\t\toptions = typeof options === \"string\" ? createOptions(options) : jQuery.extend({}, options);\n\n\t\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\n\t\t// Flag to know if list was already fired\n\t\t_fired,\n\n\n\t\t// Flag to prevent firing\n\t\t_locked,\n\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\n\t\t// Fire callbacks\n\t\tfire = function fire() {\n\n\t\t\t// Enforce single-firing\n\t\t\t_locked = options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\t_fired = firing = true;\n\t\t\tfor (; queue.length; firingIndex = -1) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile (++firingIndex < list.length) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif (!options.memory) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif (_locked) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif (memory) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\t\tlist = \"\";\n\t\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function () {\n\t\t\t\tfunction add() {\n\t\t\t\t\tif (list) {\n\n\t\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\t\tif (memory && !firing) {\n\t\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\t\tqueue.push(memory);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t(function () {\n\t\t\t\t\t\t\tfunction add(args) {\n\t\t\t\t\t\t\t\tjQuery.each(args, function (_, arg) {\n\t\t\t\t\t\t\t\t\tif (jQuery.isFunction(arg)) {\n\t\t\t\t\t\t\t\t\t\tif (!options.unique || !self.has(arg)) {\n\t\t\t\t\t\t\t\t\t\t\tlist.push(arg);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (arg && arg.length && jQuery.type(arg) !== \"string\") {\n\n\t\t\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\t\t\tadd(arg);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn add;\n\t\t\t\t\t\t})()(arguments);\n\n\t\t\t\t\t\tif (memory && !firing) {\n\t\t\t\t\t\t\tfire();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\treturn add;\n\t\t\t}(),\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function () {\n\t\t\t\tfunction remove() {\n\t\t\t\t\tjQuery.each(arguments, function (_, arg) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ((index = jQuery.inArray(arg, list, index)) > -1) {\n\t\t\t\t\t\t\tlist.splice(index, 1);\n\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif (index <= firingIndex) {\n\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\treturn remove;\n\t\t\t}(),\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function () {\n\t\t\t\tfunction has(fn) {\n\t\t\t\t\treturn fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n\t\t\t\t}\n\n\t\t\t\treturn has;\n\t\t\t}(),\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function () {\n\t\t\t\tfunction empty() {\n\t\t\t\t\tif (list) {\n\t\t\t\t\t\tlist = [];\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\treturn empty;\n\t\t\t}(),\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function () {\n\t\t\t\tfunction disable() {\n\t\t\t\t\t_locked = queue = [];\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\treturn disable;\n\t\t\t}(),\n\t\t\tdisabled: function () {\n\t\t\t\tfunction disabled() {\n\t\t\t\t\treturn !list;\n\t\t\t\t}\n\n\t\t\t\treturn disabled;\n\t\t\t}(),\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function () {\n\t\t\t\tfunction lock() {\n\t\t\t\t\t_locked = queue = [];\n\t\t\t\t\tif (!memory) {\n\t\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\treturn lock;\n\t\t\t}(),\n\t\t\tlocked: function () {\n\t\t\t\tfunction locked() {\n\t\t\t\t\treturn !!_locked;\n\t\t\t\t}\n\n\t\t\t\treturn locked;\n\t\t\t}(),\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function () {\n\t\t\t\tfunction fireWith(context, args) {\n\t\t\t\t\tif (!_locked) {\n\t\t\t\t\t\targs = args || [];\n\t\t\t\t\t\targs = [context, args.slice ? args.slice() : args];\n\t\t\t\t\t\tqueue.push(args);\n\t\t\t\t\t\tif (!firing) {\n\t\t\t\t\t\t\tfire();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\treturn fireWith;\n\t\t\t}(),\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function () {\n\t\t\t\tfunction fire() {\n\t\t\t\t\tself.fireWith(this, arguments);\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\treturn fire;\n\t\t\t}(),\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function () {\n\t\t\t\tfunction fired() {\n\t\t\t\t\treturn !!_fired;\n\t\t\t\t}\n\n\t\t\t\treturn fired;\n\t\t\t}()\n\t\t};\n\n\t\treturn self;\n\t};\n\n\treturn jQuery;\n});","ast":null,"map":{"version":3,"sources":["/packages/zurb:foundation-sites/vendor/jquery/src/callbacks.js"],"names":[],"mappings":"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","file":"/packages/zurb:foundation-sites/vendor/jquery/src/callbacks.js.map","sourcesContent":["define( [\n\t\"./core\",\n\t\"./var/rnotwhite\"\n], function( jQuery, rnotwhite ) {\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\nreturn jQuery;\n} );\n"]},"hash":"7d478da2c5b717cbf66b71ead01994ff638faaef"}
