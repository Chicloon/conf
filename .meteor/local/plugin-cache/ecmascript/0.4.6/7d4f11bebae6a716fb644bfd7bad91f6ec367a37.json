{"metadata":{"usedHelpers":["classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/zurb:foundation-sites/js/foundation.offcanvas.js","filenameRelative":"/packages/zurb:foundation-sites/js/foundation.offcanvas.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/zurb:foundation-sites/js/foundation.offcanvas.js.map","sourceFileName":"/packages/zurb:foundation-sites/js/foundation.offcanvas.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"foundation.offcanvas"},"ignored":false,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n!function ($) {\n\n  /**\n   * OffCanvas module.\n   * @module foundation.offcanvas\n   * @requires foundation.util.mediaQuery\n   * @requires foundation.util.triggers\n   * @requires foundation.util.motion\n   */\n\n  var OffCanvas = function () {\n    /**\n     * Creates a new instance of an off-canvas wrapper.\n     * @class\n     * @fires OffCanvas#init\n     * @param {Object} element - jQuery object to initialize.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n\n    function OffCanvas(element, options) {\n      (0, _classCallCheck3['default'])(this, OffCanvas);\n\n      this.$element = element;\n      this.options = $.extend({}, OffCanvas.defaults, this.$element.data(), options);\n      this.$lastTrigger = $();\n      this.$triggers = $();\n\n      this._init();\n      this._events();\n\n      Foundation.registerPlugin(this, 'OffCanvas');\n    }\n\n    /**\n     * Initializes the off-canvas wrapper by adding the exit overlay (if needed).\n     * @function\n     * @private\n     */\n\n\n    OffCanvas.prototype._init = function () {\n      function _init() {\n        var id = this.$element.attr('id');\n\n        this.$element.attr('aria-hidden', 'true');\n\n        // Find triggers that affect this element and add aria-expanded to them\n        this.$triggers = $(document).find('[data-open=\"' + id + '\"], [data-close=\"' + id + '\"], [data-toggle=\"' + id + '\"]').attr('aria-expanded', 'false').attr('aria-controls', id);\n\n        // Add a close trigger over the body if necessary\n        if (this.options.closeOnClick) {\n          if ($('.js-off-canvas-exit').length) {\n            this.$exiter = $('.js-off-canvas-exit');\n          } else {\n            var exiter = document.createElement('div');\n            exiter.setAttribute('class', 'js-off-canvas-exit');\n            $('[data-off-canvas-content]').append(exiter);\n\n            this.$exiter = $(exiter);\n          }\n        }\n\n        this.options.isRevealed = this.options.isRevealed || new RegExp(this.options.revealClass, 'g').test(this.$element[0].className);\n\n        if (this.options.isRevealed) {\n          this.options.revealOn = this.options.revealOn || this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split('-')[2];\n          this._setMQChecker();\n        }\n        if (!this.options.transitionTime) {\n          this.options.transitionTime = parseFloat(window.getComputedStyle($('[data-off-canvas-wrapper]')[0]).transitionDuration) * 1000;\n        }\n      }\n\n      return _init;\n    }();\n\n    /**\n     * Adds event handlers to the off-canvas wrapper and the exit overlay.\n     * @function\n     * @private\n     */\n\n\n    OffCanvas.prototype._events = function () {\n      function _events() {\n        this.$element.off('.zf.trigger .zf.offcanvas').on({\n          'open.zf.trigger': this.open.bind(this),\n          'close.zf.trigger': this.close.bind(this),\n          'toggle.zf.trigger': this.toggle.bind(this),\n          'keydown.zf.offcanvas': this._handleKeyboard.bind(this)\n        });\n\n        if (this.options.closeOnClick && this.$exiter.length) {\n          this.$exiter.on({ 'click.zf.offcanvas': this.close.bind(this) });\n        }\n      }\n\n      return _events;\n    }();\n\n    /**\n     * Applies event listener for elements that will reveal at certain breakpoints.\n     * @private\n     */\n\n\n    OffCanvas.prototype._setMQChecker = function () {\n      function _setMQChecker() {\n        var _this = this;\n\n        $(window).on('changed.zf.mediaquery', function () {\n          if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {\n            _this.reveal(true);\n          } else {\n            _this.reveal(false);\n          }\n        }).one('load.zf.offcanvas', function () {\n          if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {\n            _this.reveal(true);\n          }\n        });\n      }\n\n      return _setMQChecker;\n    }();\n\n    /**\n     * Handles the revealing/hiding the off-canvas at breakpoints, not the same as open.\n     * @param {Boolean} isRevealed - true if element should be revealed.\n     * @function\n     */\n\n\n    OffCanvas.prototype.reveal = function () {\n      function reveal(isRevealed) {\n        var $closer = this.$element.find('[data-close]');\n        if (isRevealed) {\n          this.close();\n          this.isRevealed = true;\n          // if (!this.options.forceTop) {\n          //   var scrollPos = parseInt(window.pageYOffset);\n          //   this.$element[0].style.transform = 'translate(0,' + scrollPos + 'px)';\n          // }\n          // if (this.options.isSticky) { this._stick(); }\n          this.$element.off('open.zf.trigger toggle.zf.trigger');\n          if ($closer.length) {\n            $closer.hide();\n          }\n        } else {\n          this.isRevealed = false;\n          // if (this.options.isSticky || !this.options.forceTop) {\n          //   this.$element[0].style.transform = '';\n          //   $(window).off('scroll.zf.offcanvas');\n          // }\n          this.$element.on({\n            'open.zf.trigger': this.open.bind(this),\n            'toggle.zf.trigger': this.toggle.bind(this)\n          });\n          if ($closer.length) {\n            $closer.show();\n          }\n        }\n      }\n\n      return reveal;\n    }();\n\n    /**\n     * Opens the off-canvas menu.\n     * @function\n     * @param {Object} event - Event object passed from listener.\n     * @param {jQuery} trigger - element that triggered the off-canvas to open.\n     * @fires OffCanvas#opened\n     */\n\n\n    OffCanvas.prototype.open = function () {\n      function open(event, trigger) {\n        if (this.$element.hasClass('is-open') || this.isRevealed) {\n          return;\n        }\n        var _this = this,\n            $body = $(document.body);\n\n        if (this.options.forceTop) {\n          $('body').scrollTop(0);\n        }\n        // window.pageYOffset = 0;\n\n        // if (!this.options.forceTop) {\n        //   var scrollPos = parseInt(window.pageYOffset);\n        //   this.$element[0].style.transform = 'translate(0,' + scrollPos + 'px)';\n        //   if (this.$exiter.length) {\n        //     this.$exiter[0].style.transform = 'translate(0,' + scrollPos + 'px)';\n        //   }\n        // }\n        /**\n         * Fires when the off-canvas menu opens.\n         * @event OffCanvas#opened\n         */\n        Foundation.Move(this.options.transitionTime, this.$element, function () {\n          $('[data-off-canvas-wrapper]').addClass('is-off-canvas-open is-open-' + _this.options.position);\n\n          _this.$element.addClass('is-open');\n\n          // if (_this.options.isSticky) {\n          //   _this._stick();\n          // }\n        });\n\n        this.$triggers.attr('aria-expanded', 'true');\n        this.$element.attr('aria-hidden', 'false').trigger('opened.zf.offcanvas');\n\n        if (this.options.closeOnClick) {\n          this.$exiter.addClass('is-visible');\n        }\n\n        if (trigger) {\n          this.$lastTrigger = trigger;\n        }\n\n        if (this.options.autoFocus) {\n          this.$element.one(Foundation.transitionend(this.$element), function () {\n            _this.$element.find('a, button').eq(0).focus();\n          });\n        }\n\n        if (this.options.trapFocus) {\n          $('[data-off-canvas-content]').attr('tabindex', '-1');\n          this._trapFocus();\n        }\n      }\n\n      return open;\n    }();\n\n    /**\n     * Traps focus within the offcanvas on open.\n     * @private\n     */\n\n\n    OffCanvas.prototype._trapFocus = function () {\n      function _trapFocus() {\n        var focusable = Foundation.Keyboard.findFocusable(this.$element),\n            first = focusable.eq(0),\n            last = focusable.eq(-1);\n\n        focusable.off('.zf.offcanvas').on('keydown.zf.offcanvas', function (e) {\n          if (e.which === 9 || e.keycode === 9) {\n            if (e.target === last[0] && !e.shiftKey) {\n              e.preventDefault();\n              first.focus();\n            }\n            if (e.target === first[0] && e.shiftKey) {\n              e.preventDefault();\n              last.focus();\n            }\n          }\n        });\n      }\n\n      return _trapFocus;\n    }();\n\n    /**\n     * Allows the offcanvas to appear sticky utilizing translate properties.\n     * @private\n     */\n    // OffCanvas.prototype._stick = function() {\n    //   var elStyle = this.$element[0].style;\n    //\n    //   if (this.options.closeOnClick) {\n    //     var exitStyle = this.$exiter[0].style;\n    //   }\n    //\n    //   $(window).on('scroll.zf.offcanvas', function(e) {\n    //     console.log(e);\n    //     var pageY = window.pageYOffset;\n    //     elStyle.transform = 'translate(0,' + pageY + 'px)';\n    //     if (exitStyle !== undefined) { exitStyle.transform = 'translate(0,' + pageY + 'px)'; }\n    //   });\n    //   // this.$element.trigger('stuck.zf.offcanvas');\n    // };\n    /**\n     * Closes the off-canvas menu.\n     * @function\n     * @param {Function} cb - optional cb to fire after closure.\n     * @fires OffCanvas#closed\n     */\n\n\n    OffCanvas.prototype.close = function () {\n      function close(cb) {\n        if (!this.$element.hasClass('is-open') || this.isRevealed) {\n          return;\n        }\n\n        var _this = this;\n\n        //  Foundation.Move(this.options.transitionTime, this.$element, function() {\n        $('[data-off-canvas-wrapper]').removeClass('is-off-canvas-open is-open-' + _this.options.position);\n        _this.$element.removeClass('is-open');\n        // Foundation._reflow();\n        // });\n        this.$element.attr('aria-hidden', 'true')\n        /**\n         * Fires when the off-canvas menu opens.\n         * @event OffCanvas#closed\n         */\n        .trigger('closed.zf.offcanvas');\n        // if (_this.options.isSticky || !_this.options.forceTop) {\n        //   setTimeout(function() {\n        //     _this.$element[0].style.transform = '';\n        //     $(window).off('scroll.zf.offcanvas');\n        //   }, this.options.transitionTime);\n        // }\n        if (this.options.closeOnClick) {\n          this.$exiter.removeClass('is-visible');\n        }\n\n        this.$triggers.attr('aria-expanded', 'false');\n        if (this.options.trapFocus) {\n          $('[data-off-canvas-content]').removeAttr('tabindex');\n        }\n      }\n\n      return close;\n    }();\n\n    /**\n     * Toggles the off-canvas menu open or closed.\n     * @function\n     * @param {Object} event - Event object passed from listener.\n     * @param {jQuery} trigger - element that triggered the off-canvas to open.\n     */\n\n\n    OffCanvas.prototype.toggle = function () {\n      function toggle(event, trigger) {\n        if (this.$element.hasClass('is-open')) {\n          this.close(event, trigger);\n        } else {\n          this.open(event, trigger);\n        }\n      }\n\n      return toggle;\n    }();\n\n    /**\n     * Handles keyboard input when detected. When the escape key is pressed, the off-canvas menu closes, and focus is restored to the element that opened the menu.\n     * @function\n     * @private\n     */\n\n\n    OffCanvas.prototype._handleKeyboard = function () {\n      function _handleKeyboard(event) {\n        if (event.which !== 27) return;\n\n        event.stopPropagation();\n        event.preventDefault();\n        this.close();\n        this.$lastTrigger.focus();\n      }\n\n      return _handleKeyboard;\n    }();\n\n    /**\n     * Destroys the offcanvas plugin.\n     * @function\n     */\n\n\n    OffCanvas.prototype.destroy = function () {\n      function destroy() {\n        this.close();\n        this.$element.off('.zf.trigger .zf.offcanvas');\n        this.$exiter.off('.zf.offcanvas');\n\n        Foundation.unregisterPlugin(this);\n      }\n\n      return destroy;\n    }();\n\n    return OffCanvas;\n  }();\n\n  OffCanvas.defaults = {\n    /**\n     * Allow the user to click outside of the menu to close it.\n     * @option\n     * @example true\n     */\n    closeOnClick: true,\n\n    /**\n     * Amount of time in ms the open and close transition requires. If none selected, pulls from body style.\n     * @option\n     * @example 500\n     */\n    transitionTime: 0,\n\n    /**\n     * Direction the offcanvas opens from. Determines class applied to body.\n     * @option\n     * @example left\n     */\n    position: 'left',\n\n    /**\n     * Force the page to scroll to top on open.\n     * @option\n     * @example true\n     */\n    forceTop: true,\n\n    /**\n     * Allow the offcanvas to remain open for certain breakpoints.\n     * @option\n     * @example false\n     */\n    isRevealed: false,\n\n    /**\n     * Breakpoint at which to reveal. JS will use a RegExp to target standard classes, if changing classnames, pass your class with the `revealClass` option.\n     * @option\n     * @example reveal-for-large\n     */\n    revealOn: null,\n\n    /**\n     * Force focus to the offcanvas on open. If true, will focus the opening trigger on close.\n     * @option\n     * @example true\n     */\n    autoFocus: true,\n\n    /**\n     * Class used to force an offcanvas to remain open. Foundation defaults for this are `reveal-for-large` & `reveal-for-medium`.\n     * @option\n     * TODO improve the regex testing for this.\n     * @example reveal-for-large\n     */\n    revealClass: 'reveal-for-',\n\n    /**\n     * Triggers optional focus trapping when opening an offcanvas. Sets tabindex of [data-off-canvas-content] to -1 for accessibility purposes.\n     * @option\n     * @example true\n     */\n    trapFocus: false\n  };\n\n  // Window exports\n  Foundation.plugin(OffCanvas, 'OffCanvas');\n}(jQuery);","ast":null,"map":{"version":3,"sources":["/packages/zurb:foundation-sites/js/foundation.offcanvas.js"],"names":[],"mappings":"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","file":"/packages/zurb:foundation-sites/js/foundation.offcanvas.js.map","sourcesContent":["'use strict';\n\n!function($) {\n\n/**\n * OffCanvas module.\n * @module foundation.offcanvas\n * @requires foundation.util.mediaQuery\n * @requires foundation.util.triggers\n * @requires foundation.util.motion\n */\n\nclass OffCanvas {\n  /**\n   * Creates a new instance of an off-canvas wrapper.\n   * @class\n   * @fires OffCanvas#init\n   * @param {Object} element - jQuery object to initialize.\n   * @param {Object} options - Overrides to the default plugin settings.\n   */\n  constructor(element, options) {\n    this.$element = element;\n    this.options = $.extend({}, OffCanvas.defaults, this.$element.data(), options);\n    this.$lastTrigger = $();\n    this.$triggers = $();\n\n    this._init();\n    this._events();\n\n    Foundation.registerPlugin(this, 'OffCanvas');\n  }\n\n  /**\n   * Initializes the off-canvas wrapper by adding the exit overlay (if needed).\n   * @function\n   * @private\n   */\n  _init() {\n    var id = this.$element.attr('id');\n\n    this.$element.attr('aria-hidden', 'true');\n\n    // Find triggers that affect this element and add aria-expanded to them\n    this.$triggers = $(document)\n      .find('[data-open=\"'+id+'\"], [data-close=\"'+id+'\"], [data-toggle=\"'+id+'\"]')\n      .attr('aria-expanded', 'false')\n      .attr('aria-controls', id);\n\n    // Add a close trigger over the body if necessary\n    if (this.options.closeOnClick) {\n      if ($('.js-off-canvas-exit').length) {\n        this.$exiter = $('.js-off-canvas-exit');\n      } else {\n        var exiter = document.createElement('div');\n        exiter.setAttribute('class', 'js-off-canvas-exit');\n        $('[data-off-canvas-content]').append(exiter);\n\n        this.$exiter = $(exiter);\n      }\n    }\n\n    this.options.isRevealed = this.options.isRevealed || new RegExp(this.options.revealClass, 'g').test(this.$element[0].className);\n\n    if (this.options.isRevealed) {\n      this.options.revealOn = this.options.revealOn || this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split('-')[2];\n      this._setMQChecker();\n    }\n    if (!this.options.transitionTime) {\n      this.options.transitionTime = parseFloat(window.getComputedStyle($('[data-off-canvas-wrapper]')[0]).transitionDuration) * 1000;\n    }\n  }\n\n  /**\n   * Adds event handlers to the off-canvas wrapper and the exit overlay.\n   * @function\n   * @private\n   */\n  _events() {\n    this.$element.off('.zf.trigger .zf.offcanvas').on({\n      'open.zf.trigger': this.open.bind(this),\n      'close.zf.trigger': this.close.bind(this),\n      'toggle.zf.trigger': this.toggle.bind(this),\n      'keydown.zf.offcanvas': this._handleKeyboard.bind(this)\n    });\n\n    if (this.options.closeOnClick && this.$exiter.length) {\n      this.$exiter.on({'click.zf.offcanvas': this.close.bind(this)});\n    }\n  }\n\n  /**\n   * Applies event listener for elements that will reveal at certain breakpoints.\n   * @private\n   */\n  _setMQChecker() {\n    var _this = this;\n\n    $(window).on('changed.zf.mediaquery', function() {\n      if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {\n        _this.reveal(true);\n      } else {\n        _this.reveal(false);\n      }\n    }).one('load.zf.offcanvas', function() {\n      if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {\n        _this.reveal(true);\n      }\n    });\n  }\n\n  /**\n   * Handles the revealing/hiding the off-canvas at breakpoints, not the same as open.\n   * @param {Boolean} isRevealed - true if element should be revealed.\n   * @function\n   */\n  reveal(isRevealed) {\n    var $closer = this.$element.find('[data-close]');\n    if (isRevealed) {\n      this.close();\n      this.isRevealed = true;\n      // if (!this.options.forceTop) {\n      //   var scrollPos = parseInt(window.pageYOffset);\n      //   this.$element[0].style.transform = 'translate(0,' + scrollPos + 'px)';\n      // }\n      // if (this.options.isSticky) { this._stick(); }\n      this.$element.off('open.zf.trigger toggle.zf.trigger');\n      if ($closer.length) { $closer.hide(); }\n    } else {\n      this.isRevealed = false;\n      // if (this.options.isSticky || !this.options.forceTop) {\n      //   this.$element[0].style.transform = '';\n      //   $(window).off('scroll.zf.offcanvas');\n      // }\n      this.$element.on({\n        'open.zf.trigger': this.open.bind(this),\n        'toggle.zf.trigger': this.toggle.bind(this)\n      });\n      if ($closer.length) {\n        $closer.show();\n      }\n    }\n  }\n\n  /**\n   * Opens the off-canvas menu.\n   * @function\n   * @param {Object} event - Event object passed from listener.\n   * @param {jQuery} trigger - element that triggered the off-canvas to open.\n   * @fires OffCanvas#opened\n   */\n  open(event, trigger) {\n    if (this.$element.hasClass('is-open') || this.isRevealed) { return; }\n    var _this = this,\n        $body = $(document.body);\n\n    if (this.options.forceTop) {\n      $('body').scrollTop(0);\n    }\n    // window.pageYOffset = 0;\n\n    // if (!this.options.forceTop) {\n    //   var scrollPos = parseInt(window.pageYOffset);\n    //   this.$element[0].style.transform = 'translate(0,' + scrollPos + 'px)';\n    //   if (this.$exiter.length) {\n    //     this.$exiter[0].style.transform = 'translate(0,' + scrollPos + 'px)';\n    //   }\n    // }\n    /**\n     * Fires when the off-canvas menu opens.\n     * @event OffCanvas#opened\n     */\n    Foundation.Move(this.options.transitionTime, this.$element, function() {\n      $('[data-off-canvas-wrapper]').addClass('is-off-canvas-open is-open-'+ _this.options.position);\n\n      _this.$element\n        .addClass('is-open')\n\n      // if (_this.options.isSticky) {\n      //   _this._stick();\n      // }\n    });\n\n    this.$triggers.attr('aria-expanded', 'true');\n    this.$element.attr('aria-hidden', 'false')\n        .trigger('opened.zf.offcanvas');\n\n    if (this.options.closeOnClick) {\n      this.$exiter.addClass('is-visible');\n    }\n\n    if (trigger) {\n      this.$lastTrigger = trigger;\n    }\n\n    if (this.options.autoFocus) {\n      this.$element.one(Foundation.transitionend(this.$element), function() {\n        _this.$element.find('a, button').eq(0).focus();\n      });\n    }\n\n    if (this.options.trapFocus) {\n      $('[data-off-canvas-content]').attr('tabindex', '-1');\n      this._trapFocus();\n    }\n  }\n\n  /**\n   * Traps focus within the offcanvas on open.\n   * @private\n   */\n  _trapFocus() {\n    var focusable = Foundation.Keyboard.findFocusable(this.$element),\n        first = focusable.eq(0),\n        last = focusable.eq(-1);\n\n    focusable.off('.zf.offcanvas').on('keydown.zf.offcanvas', function(e) {\n      if (e.which === 9 || e.keycode === 9) {\n        if (e.target === last[0] && !e.shiftKey) {\n          e.preventDefault();\n          first.focus();\n        }\n        if (e.target === first[0] && e.shiftKey) {\n          e.preventDefault();\n          last.focus();\n        }\n      }\n    });\n  }\n\n  /**\n   * Allows the offcanvas to appear sticky utilizing translate properties.\n   * @private\n   */\n  // OffCanvas.prototype._stick = function() {\n  //   var elStyle = this.$element[0].style;\n  //\n  //   if (this.options.closeOnClick) {\n  //     var exitStyle = this.$exiter[0].style;\n  //   }\n  //\n  //   $(window).on('scroll.zf.offcanvas', function(e) {\n  //     console.log(e);\n  //     var pageY = window.pageYOffset;\n  //     elStyle.transform = 'translate(0,' + pageY + 'px)';\n  //     if (exitStyle !== undefined) { exitStyle.transform = 'translate(0,' + pageY + 'px)'; }\n  //   });\n  //   // this.$element.trigger('stuck.zf.offcanvas');\n  // };\n  /**\n   * Closes the off-canvas menu.\n   * @function\n   * @param {Function} cb - optional cb to fire after closure.\n   * @fires OffCanvas#closed\n   */\n  close(cb) {\n    if (!this.$element.hasClass('is-open') || this.isRevealed) { return; }\n\n    var _this = this;\n\n    //  Foundation.Move(this.options.transitionTime, this.$element, function() {\n    $('[data-off-canvas-wrapper]').removeClass(`is-off-canvas-open is-open-${_this.options.position}`);\n    _this.$element.removeClass('is-open');\n      // Foundation._reflow();\n    // });\n    this.$element.attr('aria-hidden', 'true')\n      /**\n       * Fires when the off-canvas menu opens.\n       * @event OffCanvas#closed\n       */\n        .trigger('closed.zf.offcanvas');\n    // if (_this.options.isSticky || !_this.options.forceTop) {\n    //   setTimeout(function() {\n    //     _this.$element[0].style.transform = '';\n    //     $(window).off('scroll.zf.offcanvas');\n    //   }, this.options.transitionTime);\n    // }\n    if (this.options.closeOnClick) {\n      this.$exiter.removeClass('is-visible');\n    }\n\n    this.$triggers.attr('aria-expanded', 'false');\n    if (this.options.trapFocus) {\n      $('[data-off-canvas-content]').removeAttr('tabindex');\n    }\n  }\n\n  /**\n   * Toggles the off-canvas menu open or closed.\n   * @function\n   * @param {Object} event - Event object passed from listener.\n   * @param {jQuery} trigger - element that triggered the off-canvas to open.\n   */\n  toggle(event, trigger) {\n    if (this.$element.hasClass('is-open')) {\n      this.close(event, trigger);\n    }\n    else {\n      this.open(event, trigger);\n    }\n  }\n\n  /**\n   * Handles keyboard input when detected. When the escape key is pressed, the off-canvas menu closes, and focus is restored to the element that opened the menu.\n   * @function\n   * @private\n   */\n  _handleKeyboard(event) {\n    if (event.which !== 27) return;\n\n    event.stopPropagation();\n    event.preventDefault();\n    this.close();\n    this.$lastTrigger.focus();\n  }\n\n  /**\n   * Destroys the offcanvas plugin.\n   * @function\n   */\n  destroy() {\n    this.close();\n    this.$element.off('.zf.trigger .zf.offcanvas');\n    this.$exiter.off('.zf.offcanvas');\n\n    Foundation.unregisterPlugin(this);\n  }\n}\n\nOffCanvas.defaults = {\n  /**\n   * Allow the user to click outside of the menu to close it.\n   * @option\n   * @example true\n   */\n  closeOnClick: true,\n\n  /**\n   * Amount of time in ms the open and close transition requires. If none selected, pulls from body style.\n   * @option\n   * @example 500\n   */\n  transitionTime: 0,\n\n  /**\n   * Direction the offcanvas opens from. Determines class applied to body.\n   * @option\n   * @example left\n   */\n  position: 'left',\n\n  /**\n   * Force the page to scroll to top on open.\n   * @option\n   * @example true\n   */\n  forceTop: true,\n\n  /**\n   * Allow the offcanvas to remain open for certain breakpoints.\n   * @option\n   * @example false\n   */\n  isRevealed: false,\n\n  /**\n   * Breakpoint at which to reveal. JS will use a RegExp to target standard classes, if changing classnames, pass your class with the `revealClass` option.\n   * @option\n   * @example reveal-for-large\n   */\n  revealOn: null,\n\n  /**\n   * Force focus to the offcanvas on open. If true, will focus the opening trigger on close.\n   * @option\n   * @example true\n   */\n  autoFocus: true,\n\n  /**\n   * Class used to force an offcanvas to remain open. Foundation defaults for this are `reveal-for-large` & `reveal-for-medium`.\n   * @option\n   * TODO improve the regex testing for this.\n   * @example reveal-for-large\n   */\n  revealClass: 'reveal-for-',\n\n  /**\n   * Triggers optional focus trapping when opening an offcanvas. Sets tabindex of [data-off-canvas-content] to -1 for accessibility purposes.\n   * @option\n   * @example true\n   */\n  trapFocus: false\n}\n\n// Window exports\nFoundation.plugin(OffCanvas, 'OffCanvas');\n\n}(jQuery);\n"]},"hash":"7d4f11bebae6a716fb644bfd7bad91f6ec367a37"}
