{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/zurb:foundation-sites/vendor/jquery/src/deferred.js","filenameRelative":"/packages/zurb:foundation-sites/vendor/jquery/src/deferred.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/zurb:foundation-sites/vendor/jquery/src/deferred.js.map","sourceFileName":"/packages/zurb:foundation-sites/vendor/jquery/src/deferred.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"deferred"},"ignored":false,"code":"define([\"./core\", \"./var/slice\", \"./callbacks\"], function (jQuery, slice) {\n\n\tjQuery.extend({\n\n\t\tDeferred: function () {\n\t\t\tfunction Deferred(func) {\n\t\t\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", jQuery.Callbacks(\"memory\")]],\n\t\t\t\t    _state = \"pending\",\n\t\t\t\t    _promise = {\n\t\t\t\t\tstate: function () {\n\t\t\t\t\t\tfunction state() {\n\t\t\t\t\t\t\treturn _state;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn state;\n\t\t\t\t\t}(),\n\t\t\t\t\talways: function () {\n\t\t\t\t\t\tfunction always() {\n\t\t\t\t\t\t\tdeferred.done(arguments).fail(arguments);\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn always;\n\t\t\t\t\t}(),\n\t\t\t\t\tthen: function () {\n\t\t\t\t\t\tfunction then() /* fnDone, fnFail, fnProgress */{\n\t\t\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\t\t\treturn jQuery.Deferred(function (newDefer) {\n\t\t\t\t\t\t\t\tjQuery.each(tuples, function (i, tuple) {\n\t\t\t\t\t\t\t\t\tvar fn = jQuery.isFunction(fns[i]) && fns[i];\n\n\t\t\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\t\t\tdeferred[tuple[1]](function () {\n\t\t\t\t\t\t\t\t\t\tvar returned = fn && fn.apply(this, arguments);\n\t\t\t\t\t\t\t\t\t\tif (returned && jQuery.isFunction(returned.promise)) {\n\t\t\t\t\t\t\t\t\t\t\treturned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tnewDefer[tuple[0] + \"With\"](this === _promise ? newDefer.promise() : this, fn ? [returned] : arguments);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tfns = null;\n\t\t\t\t\t\t\t}).promise();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn then;\n\t\t\t\t\t}(),\n\n\t\t\t\t\t// Get a promise for this deferred\n\t\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\t\tpromise: function () {\n\t\t\t\t\t\tfunction promise(obj) {\n\t\t\t\t\t\t\treturn obj != null ? jQuery.extend(obj, _promise) : _promise;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn promise;\n\t\t\t\t\t}()\n\t\t\t\t},\n\t\t\t\t    deferred = {};\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\t_promise.pipe = _promise.then;\n\n\t\t\t\t// Add list-specific methods\n\t\t\t\tjQuery.each(tuples, function (i, tuple) {\n\t\t\t\t\tvar list = tuple[2],\n\t\t\t\t\t    stateString = tuple[3];\n\n\t\t\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\t\t\t_promise[tuple[1]] = list.add;\n\n\t\t\t\t\t// Handle state\n\t\t\t\t\tif (stateString) {\n\t\t\t\t\t\tlist.add(function () {\n\n\t\t\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\t\t\t_state = stateString;\n\n\t\t\t\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t\t\t}, tuples[i ^ 1][2].disable, tuples[2][2].lock);\n\t\t\t\t\t}\n\n\t\t\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\t\t\tdeferred[tuple[0]] = function () {\n\t\t\t\t\t\tdeferred[tuple[0] + \"With\"](this === deferred ? _promise : this, arguments);\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t};\n\t\t\t\t\tdeferred[tuple[0] + \"With\"] = list.fireWith;\n\t\t\t\t});\n\n\t\t\t\t// Make the deferred a promise\n\t\t\t\t_promise.promise(deferred);\n\n\t\t\t\t// Call given func if any\n\t\t\t\tif (func) {\n\t\t\t\t\tfunc.call(deferred, deferred);\n\t\t\t\t}\n\n\t\t\t\t// All done!\n\t\t\t\treturn deferred;\n\t\t\t}\n\n\t\t\treturn Deferred;\n\t\t}(),\n\n\t\t// Deferred helper\n\t\twhen: function () {\n\t\t\tfunction when(subordinate /* , ..., subordinateN */) {\n\t\t\t\tvar i = 0,\n\t\t\t\t    resolveValues = slice.call(arguments),\n\t\t\t\t    length = resolveValues.length,\n\n\n\t\t\t\t// the count of uncompleted subordinates\n\t\t\t\tremaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,\n\n\n\t\t\t\t// the master Deferred.\n\t\t\t\t// If resolveValues consist of only a single Deferred, just use that.\n\t\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\n\t\t\t\t// Update function for both resolve and progress values\n\t\t\t\tupdateFunc = function () {\n\t\t\t\t\tfunction updateFunc(i, contexts, values) {\n\t\t\t\t\t\treturn function (value) {\n\t\t\t\t\t\t\tcontexts[i] = this;\n\t\t\t\t\t\t\tvalues[i] = arguments.length > 1 ? slice.call(arguments) : value;\n\t\t\t\t\t\t\tif (values === progressValues) {\n\t\t\t\t\t\t\t\tdeferred.notifyWith(contexts, values);\n\t\t\t\t\t\t\t} else if (! --remaining) {\n\t\t\t\t\t\t\t\tdeferred.resolveWith(contexts, values);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn updateFunc;\n\t\t\t\t}(),\n\t\t\t\t    progressValues,\n\t\t\t\t    progressContexts,\n\t\t\t\t    resolveContexts;\n\n\t\t\t\t// Add listeners to Deferred subordinates; treat others as resolved\n\t\t\t\tif (length > 1) {\n\t\t\t\t\tprogressValues = new Array(length);\n\t\t\t\t\tprogressContexts = new Array(length);\n\t\t\t\t\tresolveContexts = new Array(length);\n\t\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\t\tif (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {\n\t\t\t\t\t\t\tresolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t--remaining;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If we're not waiting on anything, resolve the master\n\t\t\t\tif (!remaining) {\n\t\t\t\t\tdeferred.resolveWith(resolveContexts, resolveValues);\n\t\t\t\t}\n\n\t\t\t\treturn deferred.promise();\n\t\t\t}\n\n\t\t\treturn when;\n\t\t}()\n\t});\n\n\treturn jQuery;\n});","ast":null,"map":{"version":3,"sources":["/packages/zurb:foundation-sites/vendor/jquery/src/deferred.js"],"names":[],"mappings":"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","file":"/packages/zurb:foundation-sites/vendor/jquery/src/deferred.js.map","sourcesContent":["define( [\n\t\"./core\",\n\t\"./var/slice\",\n\t\"./callbacks\"\n], function( jQuery, slice ) {\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ) ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis === promise ? newDefer.promise() : this,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add( function() {\n\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 ||\n\t\t\t\t( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred.\n\t\t\t// If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// Add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) )\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n} );\n\nreturn jQuery;\n} );\n"]},"hash":"228a819a245b87335c26d8e35199de17dc64c30c"}
