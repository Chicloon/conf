{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/zurb:foundation-sites/vendor/jquery/src/data/Data.js","filenameRelative":"/packages/zurb:foundation-sites/vendor/jquery/src/data/Data.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/zurb:foundation-sites/vendor/jquery/src/data/Data.js.map","sourceFileName":"/packages/zurb:foundation-sites/vendor/jquery/src/data/Data.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"Data"},"ignored":false,"code":"define([\"../core\", \"../var/rnotwhite\", \"./var/acceptData\"], function (jQuery, rnotwhite, acceptData) {\n\n\tfunction Data() {\n\t\tthis.expando = jQuery.expando + Data.uid++;\n\t}\n\n\tData.uid = 1;\n\n\tData.prototype = {\n\n\t\tregister: function () {\n\t\t\tfunction register(owner, initial) {\n\t\t\t\tvar value = initial || {};\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif (owner.nodeType) {\n\t\t\t\t\towner[this.expando] = value;\n\n\t\t\t\t\t// Otherwise secure it in a non-enumerable, non-writable property\n\t\t\t\t\t// configurability must be true to allow the property to be\n\t\t\t\t\t// deleted with the delete operator\n\t\t\t\t} else {\n\t\t\t\t\t\tObject.defineProperty(owner, this.expando, {\n\t\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\treturn owner[this.expando];\n\t\t\t}\n\n\t\t\treturn register;\n\t\t}(),\n\t\tcache: function () {\n\t\t\tfunction cache(owner) {\n\n\t\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t\t// but we should not, see #8335.\n\t\t\t\t// Always return an empty object.\n\t\t\t\tif (!acceptData(owner)) {\n\t\t\t\t\treturn {};\n\t\t\t\t}\n\n\t\t\t\t// Check if the owner object already has a cache\n\t\t\t\tvar value = owner[this.expando];\n\n\t\t\t\t// If not, create one\n\t\t\t\tif (!value) {\n\t\t\t\t\tvalue = {};\n\n\t\t\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t\t\t// but we should not, see #8335.\n\t\t\t\t\t// Always return an empty object.\n\t\t\t\t\tif (acceptData(owner)) {\n\n\t\t\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t\t\t// use plain assignment\n\t\t\t\t\t\tif (owner.nodeType) {\n\t\t\t\t\t\t\towner[this.expando] = value;\n\n\t\t\t\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t\t\t\t// deleted when data is removed\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tObject.defineProperty(owner, this.expando, {\n\t\t\t\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\treturn cache;\n\t\t}(),\n\t\tset: function () {\n\t\t\tfunction set(owner, data, value) {\n\t\t\t\tvar prop,\n\t\t\t\t    cache = this.cache(owner);\n\n\t\t\t\t// Handle: [ owner, key, value ] args\n\t\t\t\tif (typeof data === \"string\") {\n\t\t\t\t\tcache[data] = value;\n\n\t\t\t\t\t// Handle: [ owner, { properties } ] args\n\t\t\t\t} else {\n\n\t\t\t\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\t\t\t\tfor (prop in meteorBabelHelpers.sanitizeForInObject(data)) {\n\t\t\t\t\t\t\tcache[prop] = data[prop];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\treturn cache;\n\t\t\t}\n\n\t\t\treturn set;\n\t\t}(),\n\t\tget: function () {\n\t\t\tfunction get(owner, key) {\n\t\t\t\treturn key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];\n\t\t\t}\n\n\t\t\treturn get;\n\t\t}(),\n\t\taccess: function () {\n\t\t\tfunction access(owner, key, value) {\n\t\t\t\tvar stored;\n\n\t\t\t\t// In cases where either:\n\t\t\t\t//\n\t\t\t\t//   1. No key was specified\n\t\t\t\t//   2. A string key was specified, but no value provided\n\t\t\t\t//\n\t\t\t\t// Take the \"read\" path and allow the get method to determine\n\t\t\t\t// which value to return, respectively either:\n\t\t\t\t//\n\t\t\t\t//   1. The entire cache object\n\t\t\t\t//   2. The data stored at the key\n\t\t\t\t//\n\t\t\t\tif (key === undefined || key && typeof key === \"string\" && value === undefined) {\n\n\t\t\t\t\tstored = this.get(owner, key);\n\n\t\t\t\t\treturn stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));\n\t\t\t\t}\n\n\t\t\t\t// When the key is not a string, or both a key and value\n\t\t\t\t// are specified, set or extend (existing objects) with either:\n\t\t\t\t//\n\t\t\t\t//   1. An object of properties\n\t\t\t\t//   2. A key and value\n\t\t\t\t//\n\t\t\t\tthis.set(owner, key, value);\n\n\t\t\t\t// Since the \"set\" path can have two possible entry points\n\t\t\t\t// return the expected data based on which path was taken[*]\n\t\t\t\treturn value !== undefined ? value : key;\n\t\t\t}\n\n\t\t\treturn access;\n\t\t}(),\n\t\tremove: function () {\n\t\t\tfunction remove(owner, key) {\n\t\t\t\tvar i,\n\t\t\t\t    name,\n\t\t\t\t    camel,\n\t\t\t\t    cache = owner[this.expando];\n\n\t\t\t\tif (cache === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (key === undefined) {\n\t\t\t\t\tthis.register(owner);\n\t\t\t\t} else {\n\n\t\t\t\t\t// Support array or space separated string of keys\n\t\t\t\t\tif (jQuery.isArray(key)) {\n\n\t\t\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\t\t\tname = key.concat(key.map(jQuery.camelCase));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcamel = jQuery.camelCase(key);\n\n\t\t\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\t\t\tif (key in cache) {\n\t\t\t\t\t\t\tname = [key, camel];\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\t\t\tname = camel;\n\t\t\t\t\t\t\tname = name in cache ? [name] : name.match(rnotwhite) || [];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ti = name.length;\n\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tdelete cache[name[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remove the expando if there's no more data\n\t\t\t\tif (key === undefined || jQuery.isEmptyObject(cache)) {\n\n\t\t\t\t\t// Support: Chrome <= 35-45+\n\t\t\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t\t\t// https://code.google.com/p/chromium/issues/detail?id=378607\n\t\t\t\t\tif (owner.nodeType) {\n\t\t\t\t\t\towner[this.expando] = undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete owner[this.expando];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn remove;\n\t\t}(),\n\t\thasData: function () {\n\t\t\tfunction hasData(owner) {\n\t\t\t\tvar cache = owner[this.expando];\n\t\t\t\treturn cache !== undefined && !jQuery.isEmptyObject(cache);\n\t\t\t}\n\n\t\t\treturn hasData;\n\t\t}()\n\t};\n\n\treturn Data;\n});","ast":null,"map":{"version":3,"sources":["/packages/zurb:foundation-sites/vendor/jquery/src/data/Data.js"],"names":[],"mappings":"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","file":"/packages/zurb:foundation-sites/vendor/jquery/src/data/Data.js.map","sourcesContent":["define( [\n\t\"../core\",\n\t\"../var/rnotwhite\",\n\t\"./var/acceptData\"\n], function( jQuery, rnotwhite, acceptData ) {\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tregister: function( owner, initial ) {\n\t\tvar value = initial || {};\n\n\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t// use plain assignment\n\t\tif ( owner.nodeType ) {\n\t\t\towner[ this.expando ] = value;\n\n\t\t// Otherwise secure it in a non-enumerable, non-writable property\n\t\t// configurability must be true to allow the property to be\n\t\t// deleted with the delete operator\n\t\t} else {\n\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\tvalue: value,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t} );\n\t\t}\n\t\treturn owner[ this.expando ];\n\t},\n\tcache: function( owner ) {\n\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return an empty object.\n\t\tif ( !acceptData( owner ) ) {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\t\t\towner[ this.expando ] && owner[ this.expando ][ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase( key ) );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.register( owner );\n\n\t\t} else {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <= 35-45+\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://code.google.com/p/chromium/issues/detail?id=378607\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\n\nreturn Data;\n} );\n"]},"hash":"be7d276af6b9a777ceed9b1f450f01a94b628614"}
